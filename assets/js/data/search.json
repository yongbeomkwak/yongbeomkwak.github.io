[ { "title": "기능개발", "url": "/posts/%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/", "categories": "Algorithm, Stack/Queue", "tags": "C++, Programmers, Lv.3", "date": "2022-05-20 15:00:00 +0900", "snippet": "순위문제 해석 순사적으로 앞의 일이 완료되어야 뒤 작업이 처리될 수 있으므로 큐를 사용#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds) { vector&lt;int&gt; answer; int n=speeds.size(); queue&lt;P&gt; q; for(int i=0;i&lt;n;i++) { q.push({progresses[i],speeds[i]}); //큐에 작업 정도와 스피드를 짝지어 넣는다. } int i=1; //해당 스피드로 일한 일 수 while(!q.empty()) // 큐가 빌 때까지 { int cnt=0; //해당 일에 끝난 작업들 if(i*q.front().second+q.front().first&lt;100) //해당 스피드 * 일한 일수 +진행 정도가 100 보다 작으면 한번더 일하므로 i++ { i++; continue; } else { while(i*q.front().second+q.front().first&gt;=100) //가장 앞이 조건을 만족한다면 계속 제거함 { cnt++; //처리 됬으므로 증가 q.pop(); } answer.push_back(cnt); //해당 끝난 작업 개수 푸쉬 백 i=1; // 다시 첫 일 부터 새기 위해서 다시 1로 } } return answer;}" }, { "title": "순위", "url": "/posts/%EC%88%9C%EC%9C%84/", "categories": "Algorithm, Graph, All pairs shortest path algorithm, 플로이드 와샬", "tags": "C++, Programmers, Lv.3", "date": "2022-05-18 15:00:00 +0900", "snippet": "순위제약 조건 승자와 패자간의 관계가 주어질 때 그 연결관계를 통해 정확한 순위 추출이 가능한 인원 카운팅 즉 이어어지는 관계가 있음문제 해석 플로이드 와샬 알고리즘을 사용하여 주어진 승자와 패자 관계를 이용해 이어지는 새로운 관계를 표시#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 101bool Prev[MAX][MAX]; //[i][j]=true , i가 j 상대로 승리int solution(int n, vector&lt;vector&lt;int&gt;&gt; results) { int answer = 0; memset(Prev,false,sizeof(Prev)); //모두 false로 초기화 for(vector&lt;int&gt; res:results) { int winner =res[0]; int loser = res[1]; Prev[winner][loser]=true; //winner가 loser를 이기므로 true } for(int mid=1;mid&lt;=n;mid++) { for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(Prev[i][mid] &amp;&amp; Prev[mid][j]) Prev[i][j]=true; //i가 mid를 이기고 mid가 j를 이기면 i가 j도 이긴다는 뜻 } } } for(int i=1;i&lt;=n;i++) { int cnt=n-1; //자신읠 제외하고 n-1 for(int j=1;j&lt;=n;j++) { if(Prev[i][j] || Prev[j][i]) cnt--; //만약 i가 j를 이거나 j가 i를 이기면 둘 관계는 승자와 패자가 확실함 } if(cnt==0) answer++; //0이 됬다는 것은 자신을 제외한 모든 사람들과 관계가 명학함으로 카운팅 } return answer;}" }, { "title": "Sorting", "url": "/posts/Sorting/", "categories": "DataStructure, Sort", "tags": "Python", "date": "2022-05-10 17:00:00 +0900", "snippet": "정렬삽입 정렬Insertion Sort: 일단 카드 하나 집고, 적절한 위치에 넣자!def insertionSort(self)-&gt;list: tmp=copy.deepcopy(self.__list) # 깊은 복사 for i in range(1,len(tmp)): for j in range(i,0,-1): #i를 기준으로 왼쪽으로 가며 i가 들어갈 자리를 찾는다. if(tmp[j]&gt;=tmp[j-1]): # 왼쪽에 있는 값이 작거나 같으면 넘어감 continue self.swap(tmp,j,j-1) #왼쪽에 값이 클 때 스왑 return tmp버블 정렬Bubble Sort: 두개씩 보고 큰 것을 오른쪽으로 보내자!def bubbleSort(self)-&gt;list: #가장 큰 것을 오른쪽 끝으로 계속 밈 tmp=copy.deepcopy(self.__list) for i in range(0,len(tmp)): for j in range(0,len(tmp)-1-i):#가장 큰겂을 (오른쪽)끝까지 미루기 때문에 미룬 횟수만큼 오른쪽 끝 위치를 왼쪽으로 당김 if(tmp[j]&lt;=tmp[j+1]): continue self.swap(tmp,j,j+1) return tmp선택 정렬Selection Sort: 가장 작은 카드를 가장 왼쪽에 놓자!def selectionSort(self)-&gt;list: tmp=copy.deepcopy(self.__list) for i in range(0,len(tmp)-1): #현재 값 currIdx:int=i for j in range(len(tmp)-1,i,-1): #끝 부분 부터 i앞 까지 if(tmp[j]&lt;tmp[currIdx]): #현재 가르키는 값이 더크면 바꿈 currIdx=j self.swap(tmp,i,currIdx) #가장 작은놈을 가르키는 인덱스와 현재 인덱스랑 변경 return tmpShell 정렬Shell Sort: Insertion sort는 ‘거의 정렬된 상태’에서 효율적이다. 리스트를 ‘거의 정렬된 상태’로 만들고, insertion sort를돌리자. def shellSort(self): tmp=copy.deepcopy(self.__list) sub_list_gap=len(tmp)//2 #서브 리스트 길이 ''' Pass1 ▪ 위치가 n/2만큼 떨어진 값을 2개씩 묶어 n/2개의 서브리스트를 생성 • 예) n = 16이면, 8개의 서브리스트 생성: (0,8), (1,9), ..., (7, 15) ▪ 각 서브리스트를 Insertion Sort로 정렬 ● Pass2 ▪ 위치가 n/4만큼 떨어진 값을 4개씩 묶어 n/4개의 서브리스트를 생성 • 예) n = 16이면,4개의 서브리스트 생성: (0,4,8,12), (1,5,9,13), ... ▪ 각 서브리스트를 Insertion Sort로 정렬 ''' while(sub_list_gap&gt;2): for j in range(0,sub_list_gap): self.insertionSort2(tmp,j,sub_list_gap) self.insertionSort2(tmp,0,1) sub_list_gap=sub_list_gap//2 return tmp def insertionSort2(self,arr:list,start:int,incr:int): for i in range(start+incr,len(arr),incr): for j in range(i,0,-incr): if(arr[j]&gt;=arr[j-incr]): continue self.swap(arr,j,j-incr)Merge 정렬Merge Sort: 분할 정복 방법 사용(재귀로 구현) $T(n)=O(NlogN)$ 별도의 tmp 리스트 필요 def merge(self,arr:list,start:int,mid:int,end:int): tmp=[ 0 for _ in range(end-start+1)] left_idx:int =start #왼쪽 시작지점 right_idx:int =mid+1 #오른쪽 시작지점 k:int=0 while(left_idx&lt;=mid and right_idx&lt;=end): if(arr[left_idx]&lt;=arr[right_idx]): #왼쪽이 작을 시 tmp[k]=arr[left_idx] #왼쪽 삽입 left_idx+=1 else: tmp[k]=arr[right_idx] #오른쪽 삽입 right_idx+=1 k+=1 # 만약 left_idx 가 mid를 넘었으면 오른쪽 배열이 남은 것 entry:int = right if left_idx&gt; mid else left_idx target:int = end if left_idx&gt; mid else mid for i in range(entry,target+1): #나머지 것 옮기고 tmp[k]=arr[i] k+=1 p:int=0 for i in range(start,end+1): #최종 정렬된 것 본 배열에 옮기기 arr[i]=tmp[p] p+=1 def mergeSort(self,arr:list,start:int,end:int): if(start&lt;end): mid=(start+end)//2 self.mergeSort(arr,start,mid) #왼쪽 self.mergeSort(arr,mid+1,end) #오른쪽 self.merge(arr,start,mid,end) #병합Quick Sort: 분할 정복 방법 사용(재귀로 구현) $T(n)=O(NlogN)$ pivot 개념이용,별도의 저장 배열 필요없은 def partition(self,arr:list,start:int,end:int): pivot:int=arr[end] i:int =start-1 for j in range(start,end): if(arr[j]&lt;=pivot): #pivot보다 작으면 왼쪽 영역을 넓힌 후 스왑 i+=1 self.swap(arr,i,j) pos:int =i+1 #마지막으로 왼쪽 영역을 넓히고 self.swap(arr,pos,end) #end를 해당 영역에 넣는다(실질적으로 바꾼다) return pos #이후 왼쪽영역 즉, 피벗 영역을 리턴한다 def quickSort(self,arr:list,start:int,end:int): if(start&lt;end): q:int=self.partition(arr,start,end) #피벗위치 #print(\"pos: \",start,end,q) self.quickSort(arr,start,q-1) # start~ 피벗 전 self.quickSort(arr,q+1,end) # 피벗 후 ~end까지" }, { "title": "안전지역", "url": "/posts/%EC%95%88%EC%A0%84%EC%A7%80%EC%97%AD/", "categories": "Algorithm, BruteForce", "tags": "BOJ, C++", "date": "2022-05-09 17:30:00 +0900", "snippet": "작업 문제링크문제분석 브루투스 포스 문제와 그래프 너비우선탐색의 혼합 문제 배열 복사 및 해당 조건(침수 유무)으로 복사한 배열 변경 너비우선 탐색을 통해 방문전체코드#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 101int arr[MAX][MAX],copyed[MAX][MAX]; //arr:입력 배열, copyed: 복사배열 int n;int max_h=0; //가장 큰 강수량(입력 높이중 최대 높이가 됨)int ans=0;int dx[]={0,0,-1,1};int dy[]={1,-1,0,0};typedef struct _POINT{ int x,y;}point;void copyArr() //복사 { for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { copyed[i][j]=arr[i][j]; } }}void getFlooding(int h) //참수{ for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(copyed[i][j]&lt;=h) copyed[i][j]=-1; //해당 h이하면 침수 } }}void push_safeArea(vector&lt;point&gt;&amp; v){ for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(copyed[i][j]!=-1) v.push_back({i,j}); //안전 지대 ,-1이 아니면 벡터에 삽입 } }}int bfs(const int h){ int ret=0; vector&lt;point&gt; v; copyArr(); //복사 getFlooding(h); //침수 push_safeArea(v);// 복사 bool visited[MAX][MAX]; memset(visited,false,sizeof(visited)); queue&lt;point&gt; q; for(point&amp; p:v) { q.push({p.x,p.y}); //해당 지대부터 출발 if(visited[p.x][p.y]) continue; //이미 방문했으면 다음 안전지대부터 시작 visited[p.x][p.y]=true; //방문안했으면 표시 while(!q.empty()) { int x=q.front().x; int y=q.front().y; q.pop(); for(int i=0;i&lt;4;i++) { const int nx=x+dx[i]; const int ny=y+dy[i]; if(nx&lt;0||ny&lt;0||nx&gt;=n||ny&gt;=n) continue; //범위를 벗어났거나 if(visited[nx][ny]) continue; //방문했으면 넘어감 if(copyed[nx][ny]!=-1) //만약 다음 지역이 -1이 아니면 방문후 삽입 { q.push({nx,ny}); visited[nx][ny]=true; } } } ret++; //큐가 끝났으면 하나의 안전지역을 묶은 것 } return ret; //해당 높이로 계산한 안전지역 갯수 리턴}int main(){ cin &gt;&gt; n; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { cin &gt;&gt; arr[i][j]; max_h=max(max_h,arr[i][j]); } } for(int i=0;i&lt;=max_h;i++) { ans=max(ans,bfs(i)); //0부터 최대 높이까지 중 최대 안전지대 리턴 } cout &lt;&lt; ans;}" }, { "title": "Union Find", "url": "/posts/UnionFind/", "categories": "DataStructure, UnionFind", "tags": "Python", "date": "2022-05-05 16:00:00 +0900", "snippet": "Union Find란? parent를 담당하는 배열이 전역으로 선언 같은 집합에 포함되어있는지. path Compression: Find연산 중 Root를 최상위로 계속 바꿔줌코드UnionFind(UnionFind.py)import sysdef union(p:list,a:int,b:int): pa:int=find(p,a) pb:int=find(p,b) if(pa&lt;pb): # pa가 작으면 p[pb]=pa #pb의 부모를 pa로 else: p[pa]=pb #pa의 부모를 pbdef find(p:list,a:int)-&gt;int: #root 찾기 r=p[a] while(r!=p[r]): #부모를 계속 접근 r=p[r] #root 찾음 #path compression(시간 복잡도를 나중에 갈수록 줄이기 위해) c:int=a while(c!=p[c]): #root 도달 전까지 pc=p[c] # 현재 c의 부모를 가르킴 p[c]=r # c의 부모를 위에서 구한 최상위 root를 가르킴 c=pc #c를 부모로 옮김 return rif __name__ ==\"__main__\": n:int=0 m:int=0 n,m=map(int,input().split()) p=[i for i in range(n+1)] #부모 배열 ,초기화는 자기자신 for _ in range(m): oper,a,b=sys.stdin.readline().rstrip().split(\" \") a=int(a) b=int(b) if(oper==\"0\"): #(Union) union(p,a,b) else: #Find pa:int=find(p,a) pb:int=find(p,b) if(pa==pb): print('YES') else: print('NO') " }, { "title": "Heap", "url": "/posts/Heap/", "categories": "DataStructure, Heap, MAXHeap", "tags": "Python", "date": "2022-05-04 00:30:00 +0900", "snippet": "힙이란? 우선순위가 있는 구조형태(우선순위 큐) 우리는 내림차순인 MAX Heap을 사용코드Heap(Heap.py)from typing import TypeVarE = TypeVar('E')class MaxHeap: def __init__(self,arr:list,num:int,max:int) -&gt; None: self.__Heap:list=arr self.__size:int=max self.__n:int=num self.buildHeap() def heapsize(self) -&gt; int: return self.__size def isLeaf(self,pos:int)-&gt;bool: if(pos&lt;self.__n and pos &gt;= self.__n//2): #만약 pos가 n보다 작고, n/2 보다 크면 자식이 없는 Leaf이다 return True return False def leftchild(self,pos:int) -&gt; E: if(2*pos+1&gt;=self.__n): #범위 넘었으면 return \"Position has no left\" return 2*pos+1 def rightchild(self,pos:int) -&gt; E: if(2*pos+2&gt;=self.__n): return \"Position has no right\" return 2*pos+2 def parent(self,pos:int)-&gt;E: if(pos&lt;=0): return \"Position has no parent\" return (pos-1)//2 # 내림연산을 위해 -1 def swap(self,i:int,j:int): tmp:E=self.__Heap[i] self.__Heap[i]=self.__Heap[j] self.__Heap[j]=tmp def shiftDown(self,pos:int): #작은 노드는 아래로 if(pos&lt;0 or self.__n&lt;=pos): return \"Illegal heap position\" while(not(self.isLeaf(pos))): j:int=self.leftchild(pos) if((j&lt;(self.__n-1)) and ((self.__Heap[j])&lt;self.__Heap[j+1])): #왼쪽이 오른쪽보다 작으면 j+=1 #오른쪽을 가르키게 한다. if(self.__Heap[pos]&gt;=self.__Heap[j]): #오른쪽보다 크거나 같으면 만족함, 탈출 return #아니면 오른쪽과 바꿔줌(j) self.swap(pos,j) pos=j # pos역시 아래로 내려감 def buildHeap(self): for i in range(self.__n//2-1,-1,-1): #자식을 갖고있는 부모 노드을 shiftDown 연산 진행 self.shiftDown(i) def insert(self,val:E): if(self.__n&gt;=self.__size): return \"Heap is Full\" curr:int=self.__n self.__Heap.append(val) self.__n+=1 while((curr!=0) and self.__Heap[curr]&gt;self.__Heap[self.parent(curr)]): #민약 부모보다 크면 변경 # Shift Up self.swap(curr,self.parent(curr)) curr=self.parent(curr) def removemax(self): if(self.__n&lt;0): return \"No items\" self.__n-=1 self.swap(0,self.__n) if(self.__n!=0): self.shiftDown(0) return self.__Heap[self.__n] def isempty(self)-&gt;bool: if(self.__n&lt;=0): return True return False def prt(self): print(self.__Heap) " }, { "title": "BinarySearchTree", "url": "/posts/BinarySearchTree/", "categories": "DataStructure, Tree, BinarySearchTree", "tags": "Python", "date": "2022-04-26 18:00:00 +0900", "snippet": "이진탐색트리란?코드ADT(Anode.py)# -*- coding: utf-8 -*-from abc import *from typing import TypeVarE = TypeVar('E')class Anode(metaclass=ABCMeta): @abstractmethod def getLeft(self)-&gt;E: pass @abstractmethod def getRight(self)-&gt;E: pass @abstractmethod def isLeaf(self)-&gt;bool: pass @abstractmethod def getItem(self)-&gt;E: passNode(Node.py)from Anode import *from typing import TypeVarE = TypeVar('E')class Node(Anode): def __init__(self,item:E,left:Anode=None,right:Anode=None): self.item:E=item self.left:Anode=left self.right:Anode=right def getItem(self) -&gt; E: return self.item def getLeft(self) -&gt; Anode: if(self.left!=None): return self.left return None def getRight(self) -&gt; Anode: if(self.right!=None): return self.right return None def isLeaf(self) -&gt; bool: if(self.left==None and self.right==None): #자식노드가 모두 없으면 True return True return False def setRight(self,n:Anode): self.right=n def setLeft(self,n:Anode): self.left=nDictionary(Dictionary.py)from typing import TypeVarfrom abc import *E = TypeVar('E')K = TypeVar('K')class Dictionary(metaclass=ABCMeta): @abstractmethod def clear(self): pass @abstractmethod def insert(self,key:K,e:E): pass @abstractmethod def remove(self,key:K)-&gt; E: pass @abstractmethod def removeAny(self) -&gt; E: pass @abstractmethod def find(self,key:K)-&gt;E: pass @abstractmethod def size(self)-&gt;int: passBST(BST.py)from re import Sfrom Dictionary import *from Node import *from typing import TypeVarfrom LNode import *E = TypeVar('E')K = TypeVar('K')class BST(Dictionary): def __init__(self): self.root:Node=None self.__size:int=0 def size(self) -&gt; int: return self.__size def clear(self): self.root=None self.__size=0 def insert(self, key: K, e: E): if(self.root==None): # 최상위가 비어있으면 설정 self.root=Node(self.Entry(key,e),None,None) else: self.insert_helper(key,e,self.root) self.__size+=1 def insert_helper(self,key:K,e:E,rt:Node)-&gt;LNode: if(rt==None): return Node(self.Entry(key,e)) # 모든 삽입 은 Node로 elif(rt.getItem().key==key): self.rt.getItem().element=e elif(rt.getItem().key&lt;key): #목표키가 현재키보다 크면 오른쪽으로 rt.setRight(self.insert_helper(key,e,rt.getRight())) else: rt.setLeft(self.insert_helper(key,e,rt.getLeft())) return rt def remove(self, key: K) -&gt; E: ret:E=self.find_helper(key,self.root) if(ret!=None): self.root=self.remove_helper(key,self.root) self.__size-=1 return ret def remove_helper(self,key:K,rt:Anode)-&gt;Anode: # 삭제하고 바뀐트리의 루트를 리턴해준다. ,왜? 해당트리의 루트를 상위 노드의 오른쪽 또는 왼쪽에 연결하면 끊김이 없음 if(rt.getItem().key&gt;key): #만약 목표 key가 현재보다 작으면 왼쪽으로 self.remove_helper(key,rt.getLeft()) elif(rt.getItem().key&lt;key): #만약 목표 key가 현재보다 크다면 오른쪽 self.remove_helper(key,rt.getRight()) else: # 찾았으면 if(rt.getLeft()==None): #만약 왼쪽만 없을 경우 return rt.getRight() # 삭제 후 서브트리의 루트를 오른쪽노드로 설정 elif(rt.getRight()==None): #만약 오른쪽만 없을 경우 return rt.getLeft() #삭제 후 서브트리의 루트를 왼쪽노드로 설정 else: #만약 왼쪽 오른쪽 둘다 있을 경우 , 오른쪽에서 가장 작은 노드를 서브트리의 루트로 lastmost=self.getLeftMost(rt.getRight()) #찾기 rt.setItem(lastmost) #찾은 값으로 변경 rt.setRight(self.removeLeftMost(rt.getRight())) #삭제후 완성된 서브트리를 오른쪽에 설정 if(rt.isLeaf()): #만약 자식이 없다면 tmp_e=rt.getItem().element tmp_k=rt.getItem().key rt=LNode(tmp_k,tmp_e) #LNode로 대체 return rt #삭제 후에도 여전히 루트는 rt이므로 def getLeftMost(self,rt:Anode): #키값이 가장 작은 노드의 값을 찾는 함수 cur:Anode=rt while(cur.getLeft()!=None): #왼쪽으로 계속 들어감 cur=cur.getLeft() return cur.getItem() def removeLeftMost(self,rt:Anode): #값을 대체한 후 삭제하는 함수 , 삭제한 후 서브트리의 루트를 리턴 if(rt.getLeft()==None): #더 이상 왼쪽이 없다면 내가 제일 작은 값, 즉 대체되었으므로 삭제되어야하는 값 return rt.getRight() # 현재 노드가 삭제되므로 오른쪽 값으로 대체된다. else: #만약 왼쪽 값이 더 남아있다면 rt.setLeft(self.removeLeftMost(rt.getLeft())) #왼쪽으로 들어간다. return rt ''' 만약 현재 삭제되어야할 노드가 15일 때 10 10 10 9 15 9 18 (오른쪽의 있는 값 중 가장 작은값으로 바꿔놓고) 9 18 5 13 18 =&gt; 5 13 20 =&gt; 5 13 20(18에 딸려옴) 11 14 11 14 11 14 12 12 12 (11을 삭제 후 11의 오른쪽 12를 13의 왼쪽으로 설정) ''' def removeAny(self): #가장 오른쪽 노드 중 , 자식이 존재하지 않으면 삭제 해당 노드 없을 시 무시 curr:Node=self.root while(curr.getRight()!=None): prev=curr curr=curr.getRight() if(curr.getLeft()==None and curr.getRight()==None): prev.setRight(None) def find(self, key: K) -&gt; E: return self.find_helper(key,self.root) def find_helper(self,k:K,rt:Node) -&gt; E: if(rt==None): #못 찾았을 때 return None if(rt.getItem().key==k): return (rt.getItem().element) elif(rt.getItem().key&lt;k): #목표키값이 현재키값보다 크면 오른쪽 return self.find_helper(k,rt.getRight()) else: #작으면 왼쪽 return self.find_helper(k,rt.getLeft()) def visit(self,node:Anode): print(node.getItem().key,end=' ') def inorder(self,node:Anode): if(node==None): return self.inorder(node.getLeft()) #왼 self.visit(node) #자기자신 self.inorder(node.getRight()) #오 def preorder(self,node:Anode): if(node==None): return self.visit(node) #자기자신 self.preorder(node.getLeft()) #왼쪽 self.preorder(node.getRight()) #오른쪽 class Entry: def __init__(self,key:K,e:E): self.key:K=key self.element:E=e 테스트(testAll.py)from BST import *if __name__==\"__main__\": bst:Dictionary=BST() bst.insert(11,\"a\") bst.insert(3,\"b\") bst.insert(5,\"c\") bst.insert(2,\"d\") print(bst.find(2)) # d print(bst.find(5)) # c print(bst.find(3)) # b print(bst.find(11)) # a print(bst.find(30)) #None" }, { "title": "연속부분최대곱", "url": "/posts/%EC%97%B0%EC%86%8D%EB%B6%80%EB%B6%84%EC%B5%9C%EB%8C%80%EA%B3%B1/", "categories": "Algorithm, DP", "tags": "BOJ, C++, 소수점 고정", "date": "2022-04-24 01:10:00 +0900", "snippet": "작업 문제링크문제분석 cout « fixed;:소수점을 고정시켜 표현을 하겠다는 뜻입니다. cout.precision(6):6자리까지 표현을 하겠다는 뜻입니다. 이 두 표현을 합치면, 소수점 6자리 표현하겠다는 뜻입니다.그러면 왜 4321.123456이 출력이 안되고 4321.123457이 되었을까?그 이유는 나머지 버리는 자리 수는 반올림이 되기 때문입니다.그래서 6째 자리까지 표현하고 7째 자리부터는 버려지기 때문에, 7째 자리인 “7”의 의미를 남기기 위해서 반올림이 되었습니다.고로, 4321.123457이 표현이 되었던 것입니다전체코드#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 10001int n;double arr[MAX];double dp[MAX];int main(){ cin &gt;&gt; n; cout &lt;&lt; fixed; //소수 점 고정 \tcout.precision(3); //4자리에서 반올림 for(int i=0;i&lt;n;i++) cin &gt;&gt; arr[i]; dp[0]=arr[0]; double ret=0.0; for(int i=1;i&lt;n;i++) { dp[i]=max(arr[i],arr[i]*dp[i-1]); ret=max(dp[i],ret); } cout &lt;&lt; ret;}" }, { "title": "로봇 조종하기", "url": "/posts/%EB%A1%9C%EB%B4%87-%EC%A1%B0%EC%A2%85%ED%95%98%EA%B8%B0/", "categories": "Algorithm, DP", "tags": "BOJ, C++", "date": "2022-04-22 17:00:00 +0900", "snippet": "작업 문제링크문제분석 좌 우 아래, 3방향 이동 시 탐색을 통하지 않고 처리하는 방법을 공부 아래로 내려오는 것은 반복문 , 좌 우는 각 각, Left Right 행렬을 만들어 3방향에서 최댓값을 찾은 후 dp에 저장한다전체코드#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 1001#define INF 9876543int n,m;int dp[MAX][MAX];int gmap[MAX][MAX];int Right[MAX]={0,};int Left[MAX]={0,};int ans=0;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;m;j++) { cin &gt;&gt; gmap[i][j]; } } dp[0][0]=gmap[0][0]; for(int i=1;i&lt;m;i++) //0번 째 행은 오른쪽 이동으로만 더해짐 { dp[0][i]+=dp[0][i-1]+gmap[0][i]; } for(int i=1;i&lt;n;i++) { //왼쪽에서 오른쪽으로 Right[0]=dp[i-1][0]+gmap[i][0]; //첫 right[0]= dp[i-1][0](바로 위) + map[i][0] for(int j=1;j&lt;m;j++) { Right[j]=max(Right[j-1],dp[i-1][j])+gmap[i][j]; // (왼쪽 값,위에서 내려온 값)최댓값 + map } Left[m-1]=dp[i-1][m-1]+gmap[i][m-1]; //왼쪽에서 오른쪽으로 for(int j=m-2;j&gt;=0;j--) { Left[j]=max(Left[j+1],dp[i-1][j])+gmap[i][j]; //(오른쪽 값,위에서 내려오는 값)최댓값 +map } for (int k = 0; k &lt; m; k++)\t\t\tdp[i][k] = max(Right[k], Left[k]); //해당 열의 왼쪽, 오른쪽 중 큰값 을 넣어준다. } cout &lt;&lt; dp[n-1][m-1];}" }, { "title": "작업", "url": "/posts/%EC%9E%91%EC%97%85/", "categories": "Algorithm, DP", "tags": "BOJ, C++, 위상정렬", "date": "2022-04-15 23:40:00 +0900", "snippet": "작업 문제링크문제분석 위상정렬, 왜 Why? 작업의 순서가 있으므로 위상정렬은 벡터(간선관계) ,queue를 이용하여 해당 작업을 수행가능할 때 넣음 수행가능한 작업이란 들어간는 간선의 개수가 0이란 뜻 해당 작업이 호출 될 때마다 간선을 하나씩 제거 , 그 이후 0이되면 큐에 삽입전체코드#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 10001int n;int times[MAX]={0,};int dp[MAX]={0,};int edges[MAX]={0,};vector&lt;int&gt; graph[MAX];int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt;n; int ret=0; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;times[i]; dp[i]=times[i]; //작업 시간 int edge; cin &gt;&gt; edge; edges[i]=edge; //간선 갯수 for(int j=0;j&lt;edge;j++) { int pre; cin &gt;&gt; pre; graph[pre].push_back(i); // pre-&gt; i ,pre에서 i로 들어오는 간선 입력 } } for(int i=1; i&lt;=n; i++) if(edges[i]==0) // 들어오는 간선이 없는 애들 담음 q.push(i); while(!q.empty()){ int now = q.front(); q.pop(); for(int i=0; i&lt;graph[now].size(); i++){ int next = graph[now][i]; // now의 다음 목적지 dp[next] = max(dp[next],dp[now]+times[next]); //next의 dp시간과,현재 + next 시간 중 큰 값 사용 edges[next]--; // if(edges[next]==0) //이제 next로 들어갈 수 있다면(next를 처리할 수 있다면) q.push(next); } } for(int i=1; i&lt;=n; i++) ret = max(ret,dp[i]); cout&lt;&lt;ret; }" }, { "title": "ArrayTree", "url": "/posts/ArrayTree/", "categories": "DataStructure, Tree, ArrayTree", "tags": "Python", "date": "2022-04-12 15:00:00 +0900", "snippet": "배열기반 트리란? 배열기반 트리 제약조건 Complete Binary Tree 해당 인덱스가 범위를 벗어났는지 또는 다른 조건을 만족하는지 선행체크 import mathclass ArrayTree: def __init__(self) -&gt; None: self.tree=['A','B','C','D','E','F','G','H','I','J','K','L'] self.size:int=len(self.tree) def parent(self,curr:int): # 해당 curr의 부모 찾기 if(curr&gt;0): return self.tree[math.floor((curr-1)/2)] else : return \"It is root\" def leftchild(self,curr:int): #left=2n+1 if(2*curr+1&lt;self.size): return self.tree[2*curr+1] else: return \"No left Child\" def rightchild(self,curr:int): #right=2n+2 if(2*curr+2&lt;self.size): return self.tree[2*curr+2] else: return \"No right Child\" def leftSibling(self,curr): #left Sibling=n-1 if(curr%2==0): return self.tree[curr-1] return \"No left Sibling\" def rightSibling(self,curr): #right sibling=n+1 if(curr%2!=0 and curr+1&lt;self.size): return self.tree[curr+1] return \"No right Sibling\" " }, { "title": "모음의 개수", "url": "/posts/%EB%AA%A8%EC%9D%8C%EC%9D%98-%EA%B0%9C%EC%88%98/", "categories": "Algorithm, String", "tags": "BOJ, C++", "date": "2022-04-10 23:55:00 +0900", "snippet": "모음의 개수 문제링크문제분석 char* strchr (char* str, int c); 해당 문자열(str)에 해당 문자 c가 존재하면 해당 존재하는 곳 포인터 없으면 Null전체코드#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string s; cin &gt;&gt; s; int ret=0; for(int i=0;i&lt;s.length();i++) { if(strchr(\"aeiou\",s[i]))ret ++; /* char* strchr (char* str, int c); 해당 문자열(str)에 해당 문자 c가 존재하면 해당 존재하는 곳 포인터 없으면 Null */ } cout &lt;&lt;ret;}" }, { "title": "문자열 분석", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4%EB%B6%84%EC%84%9D/", "categories": "Algorithm, String", "tags": "BOJ, C++", "date": "2022-04-08 00:00:00 +0900", "snippet": "문자열 분석 문제링크문제분석 is 시리즈 isupper(c) islower(c) isdigit(c) isspace(c)전체코드#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); while (1) { string in; getline(cin, in); if (in == \"\") break; int *arr; arr = (int *)calloc(4, sizeof(int)); for (const char &amp;c : in) { if (islower(c)) { arr[0]++; continue; } if (isupper(c)) { arr[1]++; continue; } if (isdigit(c)) { arr[2]++; continue; } if (isspace(c)) { arr[3]++; } } cout &lt;&lt; arr[0] &lt;&lt; \" \" &lt;&lt; arr[1] &lt;&lt; \" \" &lt;&lt; arr[2] &lt;&lt; \" \" &lt;&lt; arr[3] &lt;&lt; endl; free(arr); }}" }, { "title": "BinaryTree", "url": "/posts/BinaryTree/", "categories": "DataStructure, Tree, BinaryTree", "tags": "Python", "date": "2022-04-07 15:30:00 +0900", "snippet": "이진트리란?이진트리 종류Full Binary Tree , Complete Binary TreePerfect Binary TreeBinary Node ADT순회코드ADT(Anode.py)# -*- coding: utf-8 -*-from abc import *from typing import TypeVarE = TypeVar('E')class Anode(metaclass=ABCMeta): @abstractmethod def getLeft(self)-&gt;E: pass @abstractmethod def getRight(self)-&gt;E: pass @abstractmethod def isLeaf(self)-&gt;bool: pass @abstractmethod def getItem(self)-&gt;E: passNode(Node.py)from Anode import *from typing import TypeVarE = TypeVar('E')class Node(Anode): def __init__(self,item:E,left:Anode=None,right:Anode=None): self.item:E=item self.left:Anode=left self.right:Anode=right def getItem(self) -&gt; E: return self.item def getLeft(self) -&gt; Anode: if(self.left!=None): return self.left return None def getRight(self) -&gt; Anode: if(self.right!=None): return self.right return None def isLeaf(self) -&gt; bool: if(self.left==None and self.right==None): #자식노드가 모두 없으면 True return True return FalseTree(BinaryTree.py)from Node import *from typing import TypeVarfrom Lnode import *E = TypeVar('E')class BinaryTree: def __init__(self,root:Node): self.__root:Node=root def insert_Node(self,parent:Node,node:Node): #부모노드와 자식노드 if(node.getItem()&lt;parent.getItem()): # 부모보다 작으면 왼쪽 if(parent.left==None): #비어있으면 parent.left=node return else: #있다면 해당 왼쪽을 기준으로 재귀 self.insert_Node(parent.left,node) else: if(parent.right==None):#비어있으면 parent.right=node return else: #오른쪽으로 재귀 self.insert_Node(parent.right,node) def getRoot(self)-&gt;Node: return self.__root def visit(self,node:Node): print(node.getItem(),end=\" \") def preorder(self,node:Anode): if(node==None): return self.visit(node) #자기자신 self.preorder(node.getLeft()) #왼쪽 self.preorder(node.getRight()) #오른쪽 def postorder(self,node:Anode): if(node==None): return self.postorder(node.getLeft()) #왼 self.postorder(node.getRight()) #오 self.visit(node) #자기자신 def inorder(self,node:Anode): if(node==None): return self.inorder(node.getLeft()) #왼 self.visit(node) #자기자신 self.inorder(node.getRight()) #오 테스트(testAll.py)from BinaryTree import *from Node import *if __name__==\"__main__\": d:Node = LNode(\"D\") g:Node = LNode(\"G\") h:Node = LNode(\"H\") i:Node = LNode(\"I\") b:Node = Node(\"B\",right=d) e:Node = Node(\"E\",left=g) f:Node = Node(\"F\",h,i) c:Node = Node(\"C\",e,f) a:Node = Node(\"A\",b,c) btree=BinaryTree(a) btree.preorder(btree.getRoot()) print() btree.inorder(btree.getRoot()) print() btree.postorder(btree.getRoot())최종 구조결과" }, { "title": "Tree", "url": "/posts/Tree/", "categories": "DataStructure, Tree", "tags": "Python", "date": "2022-04-07 15:00:00 +0900", "snippet": "트리란? 자료구조의 기본 트리는 루트가 있는 트리이고 그래프이론의 트리는 루트가 없는 트리 즉 Acyclic(순환이 없고) Undirected(무방향성) Connected(연결) 그래프이다 Tree의 구성요소노드의 종류부모와 자식단말과 내부조상과 자손깊이와 레벨" }, { "title": "단어 뒤집기", "url": "/posts/%EB%8B%A8%EC%96%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/", "categories": "Algorithm, String", "tags": "BOJ, C++", "date": "2022-04-06 20:40:00 +0900", "snippet": "단어 뒤집기 문제링크문제분석 cin은 ‘\\n’를 변수에 담지 않는다. (입력버퍼에 남겨둔다.) getline은 ‘\\n’를 변수에 담는다. cin.ignore():버퍼 전체를 비우는것이 아니라 맨 앞의 문자하나(‘\\n’)를 지운다. 문자열 스트림을 이용하여 공백을 통해 짤름 getline(cin,tmp): tmp에 cin(입력)을 담음 getline(ss,tmp,delim): ss(문자열 스트림) 내용울 구분자(delim)로 짤라 tmp에 차례대로 담음 reverse(s.begin(),s.end()): 문자열 뒤집기(전체 순서와 각 순서 바뀜) ex) s= “abc def hij” -&gt;”jih fed cba” 전체코드#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int tc; cin &gt;&gt; tc; cin.ignore(); //테스트 케이스를 받은 후 다음 입력을 위해 cin을 비움 while(tc--) { string in; string ret; getline(cin,in); //공백 포함 받은 후 reverse(in.begin(),in.end()); //모든 문자열을 뒤집고 (i love u) -&gt; (u evol i) string tmp; stringstream ss(in); //스트링 스트림에 넣어놓고 while(getline(ss,tmp,' ')) //빈칸 기준으로 나누고 { string tt=ret; //이전 값 ret=tmp+\" \"+tt; //새로운 값 + 빈칸 + 이전 값을 쌓음 } cout &lt;&lt;ret&lt;&lt;endl; }}" }, { "title": "30", "url": "/posts/30/", "categories": "Algorithm, String", "tags": "BOJ, C++, 정수론", "date": "2022-04-05 17:05:00 +0900", "snippet": "30 문제링크문제분석 30의 배수를 10과 3의 배수 두가지로 나눠 생각 3의 배수 특징: 모든 자리 수를 더했을 때 3으로 나눠짐 int to char: (char)(i+48) count(v.begin(),v.end(),num): 해당 값 갯수, string이므로 num은 char 타입이 되야함전체코드#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[10];int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string a; bool error = false; // error 플래그 string ret; cin &gt;&gt; a; for (int i = 0; i &lt;= 9; i++) // 0~9 개수를 카운ㅌ { cnt[i] = count(a.begin(), a.end(), (char)(i + 48)); // int to char } // 30의 배수 = 10배수 and 3의 배수 ,10 배수: 0이 존재해야 가능 ,3의 배수: 모든 수를 합할 시 3으로 나눠짐 if (cnt[0] == 0) error = true; // 0이 없으면 10의 배수가 안됨 else { int sum = 0; for (int i = 0; i &lt;= 9; i++) { sum += i * cnt[i]; } if (sum % 3 != 0) error = true; //모든 자리의 합이 3으로 나눠져야 3의 배수 else { for (int i = 9; i &gt;= 0; i--) // 내림차순이므로 9부터 해당 개수만큼 문자열에 붙힘 { for (int j = 0; j &lt; cnt[i]; j++) { ret += (char)(i + 48); } } } } if (error) cout &lt;&lt; -1; // error 존재 시 -1 else cout &lt;&lt; ret;}" }, { "title": "Queue", "url": "/posts/Queue/", "categories": "DataStructure, Queue", "tags": "Python", "date": "2022-04-05 15:50:00 +0900", "snippet": "큐란? FIFO:First In First Out 리스트의 제한된 형태: 한쪽 끝에서만 넣고, 다른쪽으로 뺌Queue구조의 ADT ADT(Aqueue.py)# -*- coding: utf-8 -*-from abc import *from typing import TypeVarfrom Dlink import *E = TypeVar('E')class Aqueue(metaclass=ABCMeta): @abstractmethod def push(self,item:E): pass @abstractmethod def pop(self)-&gt;E: pass @abstractmethod def front(self)-&gt;E: pass @abstractmethod def rear(self)-&gt;E: pass @abstractmethod def clear(self): pass @abstractmethod def empty(self)-&gt; bool: pass Queue(Queue.py)# -*- coding: utf-8 -*-from typing import TypeVarfrom pytest import Itemfrom Dlink import *from Aqueue import *E = TypeVar('E')class Queue(Aqueue): def __init__(self) -&gt; None: self.head:Dlink=Dlink(None,None,None) self.tail:Dlink=Dlink(None,self.head,None) self.head.next=self.tail self.size:int=0 ## 서로 연결 head와 tail def push(self, item: E): new:Dlink=Dlink(item,self.head,self.head.next) # prev :head next: head.next self.head.next.prev=new # 이전노드 new self.head.next=new #다음노드 new self.size+=1 def pop(self) -&gt; E: if(self.size==0): return \"No item\" ret:E=self.tail.prev.item #리턴 값 self.tail.prev.prev.next=self.tail #2번째 전 다음 노드 tail self.tail.prev=self.tail.prev.prev #tail의 이전노드 2번째 전 self.size-=1 return ret def front(self) -&gt; E: if(self.size==0): return \"No item\" return self.head.next.item #front def rear(self) -&gt; E: if(self.size==0): return \"No item\" return self.tail.prev.item #back def clear(self): self.head.next=self.tail self.tail.prev=self.head self.size=0 #재 설정 def empty(self) -&gt; bool: if(self.size==0): return True return False 실제 구현동작 확인(test.py)from numpy import emptyfrom ArrayList import *from LinkedList import *from DoubleLinkedList import *from Stack import *from Link import *from Queue import *if __name__==\"__main__\": q=Queue() q.push(1) print(f'front: {q.front()}, rare: {q.rear()}') q.push(2) print(f'front: {q.front()}, rare: {q.rear()}') q.push(3) print(f'front: {q.front()}, rare: {q.rear()}') q.clear() print(f'front: {q.front()}, rare: {q.rear()}') q.push(123) q.push(456) q.push(\"HAHA\") while(not(q.empty())): print(q.pop())결과" }, { "title": "Stack", "url": "/posts/Stack/", "categories": "DataStructure, Stack", "tags": "Python", "date": "2022-04-05 14:50:00 +0900", "snippet": "스택이란?Stack구조의 ADT ADT(Astack.py)# -*- coding: utf-8 -*-from abc import *from typing import TypeVarfrom Link import *E = TypeVar('E')class Astack(metaclass=ABCMeta): @abstractmethod def clear(self): pass @abstractmethod def push(self,item:E): pass @abstractmethod def pop(self)-&gt;E: pass @abstractmethod def topValue(self)-&gt;E: pass @abstractmethod def length(self)-&gt;int: pass @abstractmethod def empty(self)-&gt;bool: pass Link(Link.py)# -*- coding: utf-8 -*-from typing import TypeVarE = TypeVar('E')class Link: def __init__(self,item:E,next): self.item:E=item self.next:Link=next Stack(Stack.py)from sympy import truefrom Astack import * from Link import *class Stack(Astack): def __init__(self): self.size:int=0 self.top:Link=Link(None,None) #Dummy Node def length(self) -&gt; int: return self.size def push(self, item: E): new:Link=Link(item,self.top.next) # 새노드의 다음을 다음 걸로 지정 self.top.next=new #top의 다음을 new로 지정 self.size+=1 def pop(self) -&gt; E: if(self.size==0): return \"No item\" ret:E=self.top.next.item # 리턴 값 self.top.next=self.top.next.next #top의 다음 값을 재설정 다다음 것으로 self.size-=1 return ret def topValue(self) -&gt; E: if(self.size==0): return \"No item\" return self.top.next.item def clear(self): #초기화 self.top.next=None self.size=0 def empty(self) -&gt; bool: #비어있는지 확인 if(self.size==0): return True return False 실제 구현동작 확인(test.py)from numpy import emptyfrom ArrayList import *from LinkedList import *from DoubleLinkedList import *from Stack import *from Link import *from Queue import *if __name__==\"__main__\": st=Stack() st.push(3) st.push(2) st.push(1) while(not(st.empty())): print(st.pop())결과" }, { "title": "AC", "url": "/posts/AC/", "categories": "Algorithm, String", "tags": "BOJ, C++, Deque", "date": "2022-04-04 00:05:00 +0900", "snippet": "AC 문제링크문제분석 STL deque 사용 (앞과 뒤) 삽입 삭제 가능 deque Reference전체코드#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); int tc; cin &gt;&gt; tc; while (tc--) { deque&lt;int&gt; dq; //덱 선언 bool error = false, reverse = false; //error 플래그와 reverse 플래그 string command, arr; int n; cin &gt;&gt; command; cin &gt;&gt; n; cin &gt;&gt; arr; string tmp = \"\"; for (const char &amp;c : arr) { if (isdigit(c)) //만약 숫자면 tmp += c; //누적 else //다른 것이 들어오면 지금까지 누적한 숫자문자열을 int로 변환 { if (tmp.empty()) //비어있으면 continue continue; dq.push_back(stoi(tmp)); tmp.clear(); //비워주고 } } for (const char &amp;c : command) { if (c == 'R') //만약 R이면 reverse reverse = !reverse; else //만약 D인데 { if (dq.size() == 0) //아무것도 없으면 error 플래그 켜주고 중단 { error = true; break; } if (reverse) //만약 뒤집힌 상태에서 D면 뒤에 것 제거 dq.pop_back(); else dq.pop_front(); //앞에꺼 제거 } } if (error) //error면 error cout &lt;&lt; \"error\" &lt;&lt; endl; else { cout &lt;&lt; \"[\"; while (!dq.empty()) { if (dq.size() == 1) //덱에 하나 뿐이면 뒤에 ,(쉼표)는 없어야함 { cout &lt;&lt; dq.front(); dq.pop_front(); } else { if (reverse) //뒤집힌 상태면 back면 back에서 부터 배출 { cout &lt;&lt; dq.back() &lt;&lt; \",\"; dq.pop_back(); } else //아니면 앞 부터 배출 { cout &lt;&lt; dq.front() &lt;&lt; \",\"; dq.pop_front(); } } } cout &lt;&lt; \"]\" &lt;&lt; endl; } }}" }, { "title": "펠린드롬수", "url": "/posts/%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC%EC%88%98/", "categories": "Algorithm, String", "tags": "BOJ, C++", "date": "2022-04-02 15:30:00 +0900", "snippet": "펠린드롬수 문제링크문제분석 str1.compare(str2): 같으면 0 getline(cin,str): 입력값을 str에 저장 reverse(str1.begin(),str2.end()):뒤집기전체코드#include &lt;bits/stdc++.h&gt;using namespace std;bool check_palindrome(const string&amp; s){ bool ret; if(s.length()%2==0) { const int mid=s.length()/2; string l=s.substr(0,mid); string r=s.substr(mid); reverse(r.begin(),r.end()); if(!l.compare(r)) ret= true; else ret= false; } else { const int mid=s.length()/2; string l=s.substr(0,mid); string r=s.substr(mid+1); //중간 건너 뛰고 reverse(r.begin(),r.end()); if(!l.compare(r)) ret= true; else ret= false; } return ret;}int main(){ string str; while(getline(cin,str)) { if(str==\"0\") break; check_palindrome(str) == true ? cout &lt;&lt; \"yes\" : cout &lt;&lt;\"no\"; cout &lt;&lt; endl; } }" }, { "title": "Double Linked List", "url": "/posts/List4/", "categories": "DataStructure", "tags": "List, Python", "date": "2022-04-01 16:00:00 +0900", "snippet": "이중연결 리스트 단일 연결리스트의 탐색 부분을 보완 pos를 현재 리스트 사이즈를 기준으로 이중탐색 진행 하여 , head에서 가까운 head부터 tail에서 가까우면 tail부터 접근 ListIterator(ListIterator.py)from abc import *from typing import TypeVarE = TypeVar('E')class ListIterator(object): __metaclass__ = ABCMeta @abstractmethod def hasNext(self) -&gt;bool: pass @abstractmethod def next(self) -&gt;E: pass @abstractmethod def hasPrevious(self) -&gt;bool: pass @abstractmethod def previous(self) -&gt;E: pass ADT(Dlist.py)# -*- coding: utf-8 -*-from abc import *from typing import TypeVarfrom ListIterator import *E = TypeVar('E')class Dlist: __metaclass__ = ABCMeta @abstractmethod def clear(self): pass @abstractmethod def insert(self,pos:int,item:E): pass @abstractmethod def append_front(self,item:E): pass @abstractmethod def append_back(self,item:E): pass @abstractmethod def update(self,pos:int,item:E): pass @abstractmethod def getValue(self,pos:int)-&gt;E: pass @abstractmethod def pop_back(self)-&gt;E: pass @abstractmethod def pop_front(self)-&gt;E: pass @abstractmethod def remove(self,pos:int)-&gt;E: pass @abstractmethod def length(self) -&gt; int: pass @abstractmethod def listIterator(self) -&gt; ListIterator : #반복자 pass Dlink(Dlink.py)# -*- coding: utf-8 -*-from typing import TypeVarE = TypeVar('E')class Dlink(): def __init__(self,item:E,prev,next): self.item:E=item self.prev:Dlink=prev self.next:Dlink=next DoubleLinkedList(DoubleLinkedList.py)# -*- coding: utf-8 -*-from typing import TypeVarfrom Dlink import *from ListIterator import *from Dlist import DlistE = TypeVar('E')class DoubleLinkedList(Dlist): def __init__(self) -&gt; None: self.head:Dlink=Dlink(None,None,None) # 별도의 head .next를 tail self.tail:Dlink=Dlink(None,self.head,None) # 별도의 tail .prev를 head self.head.next=self.tail self.size=0 def length(self) -&gt; int: return self.size def append_front(self, item: E): new:Dlink=Dlink(item,self.head,self.head.next) #새로운 노드 생성(이전을 head,다음을 head.next) self.head.next.prev=new #해당 노드의 이전노드를 새노드 넣어주고 self.head.next=new # head의 다음을 새 노드로 self.size+=1 def append_back(self, item: E): new:Dlink=Dlink(item,self.tail.prev,self.tail) # 이전을 tail의 prev ,다음을 tail self.tail.prev.next=new # tail.prev의 다음을 new self.tail.prev=new #tail이전을 new self.size+=1 def insert(self, pos: int, item: E): if(pos&gt;=self.size): print(\"Out of Bound\") return curr:Dlink=self.head.next #head의 다음부터 시작 for _ in range(pos): curr=curr.next new:Dlink=Dlink(item,curr.prev,curr) # curr을 뒤로 밀어낸다. curr.prev.next=new #이전의 다음을 new로 curr.prev=new #이전을 new로 self.size+=1 def remove(self, pos: int) -&gt; E: if(pos&gt;=self.size): print(\"Out of Bound\") return curr:Dlink=self.head.next #head의 다음부터 시작 for _ in range(pos): curr=curr.next curr.next.prev=curr.prev #다음노드의 이전 노드를 변경 curr.prev.next=curr.next #이전노드의 다음 노드를 변경 self.size-=1 return curr.item def pop_front(self)-&gt;E: if(self.size==0): return \"No Item\" else: ret:E=self.head.next.item curr:Dlink=self.head.next self.head.next=curr.next # head 다음을 변경 curr.next.prev=self.head # 다음 것의 이전을 헤드로 연결 self.size-=1 return ret def pop_back(self) -&gt; E: if(self.size==0): return \"No Item\" else: ret:E=self.tail.prev.item curr:Dlink=self.tail.prev #가장 마지막 원소 self.tail.prev=curr.prev #tail의 이전원소 변경 curr.prev.next=self.tail #이전 원소의 다음을 tail로 변경 self.size-=1 return ret def update(self, pos: int, item: E): if(self.size&lt;=pos): print(\"Out of Bound\") return if(pos&lt;=self.size//2): # 중간지점 보다 작으면 head부터 curr:Dlink=self.head.next # for _ in range(pos): curr=curr.next curr.item=item else: #tail부터 curr:Dlink=self.tail.prev reverse_pos:int=self.size-1-pos for _ in range(reverse_pos): curr=curr.prev curr.item=item def getValue(self, pos: int)-&gt;E: if(self.size&lt;=pos): print(\"Out of Bound\") return if(pos&lt;=self.size//2): # 중간지점 보다 작으면 head부터 curr:Dlink=self.head.next # for _ in range(pos): curr=curr.next return curr.item else: #tail부터 curr:Dlink=self.tail.prev reverse_pos:int=self.size-1-pos for _ in range(reverse_pos): curr=curr.prev return curr.item def clear(self): #초기화 self.head:Dlink=Dlink(None,None,None) # 별도의 head .next를 tail self.tail:Dlink=Dlink(None,self.head,None) # 별도의 tail .prev를 head self.head.next=self.tail self.size=0 def listIterator(self) -&gt; ListIterator: return self.DoubleLinkedListIterator(self) class DoubleLinkedListIterator(ListIterator): def __init__(self,outer): self.outer:DoubleLinkedList=outer self.curr:Dlink=self.outer.head # head부터 self.rev_curr:Dlink=self.outer.tail # tail 부터 def hasNext(self) -&gt; bool: return self.curr!=self.outer.tail.prev #tail 이전노드면 더 이상 다음은 없음 def next(self) -&gt; E: self.curr=self.curr.next return self.curr.item def previous(self) -&gt; E: self.rev_curr=self.rev_curr.prev return self.rev_curr.item def hasPrevious(self) -&gt; bool: return self.rev_curr!=self.outer.head.next # head 다음 노드가 아니면 previous를 갖고있다 실제 구현동작 확인(test.py)from ArrayList import *from LinkedList import *if __name__==\"__main__\": ylist3=DoubleLinkedList() mylist3.append_front(6) mylist3.append_front(5) mylist3.append_front(4) mylist3.append_front(3) mylist3.remove(2) # 3 4 6 mylist3.append_back(99) # 3 4 6 99 mylist3.update(3,11) # 3 4 6 11 mylist3.pop_back() # 3 4 6 mylist3.pop_front() # 4 6 iter3:ListIterator=mylist3.listIterator() while(iter3.hasPrevious()): print(iter3.previous(),end=' ') # 6 4 보완할 점Iterator 좀 더 공부하여 적용해 보기" }, { "title": "그대로 출력하기 2", "url": "/posts/%EA%B7%B8%EB%8C%80%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0-2-copy/", "categories": "Algorithm, String", "tags": "BOJ, C++", "date": "2022-04-01 10:40:00 +0900", "snippet": "그대로 출력하기 2 문제링크문제분석 cin.eof(): EOF getline(cin,str): 입력값을 str에 저장전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int main(void) { string str; for (int i = 0; i &lt; 100 &amp;&amp; !cin.eof(); i++) { getline(cin, str); cout &lt;&lt; str &lt;&lt; endl; } return 0; }" }, { "title": "ArrayList and LinkedList With Iterator ", "url": "/posts/List3/", "categories": "DataStructure, ListIterator", "tags": "Python", "date": "2022-03-31 16:50:00 +0900", "snippet": "리스트란?List구조의 ADT ADT: Abstract Data Type Java의 인터페이스 역할 ListIterator(ListIterator.py)from abc import *from typing import TypeVarE = TypeVar('E')class ListIterator(metaclass=ABCMeta): @abstractmethod def hasNext(self) -&gt;bool: pass @abstractmethod def next(self) -&gt;E: pass @abstractmethod def hasPrevious(self) -&gt;bool: pass @abstractmethod def previous(self) -&gt;E: pass ADT(List.py)# -*- coding: utf-8 -*-from abc import *from typing import TypeVarfrom ListIterator import *E = TypeVar('E')class List(object): __metaclass__ = ABCMeta @abstractmethod def clear(self): pass @abstractmethod def insert(self,pos:int,item:E): pass @abstractmethod def append(self,item:E): pass @abstractmethod def update(self,pos:int,item:E): pass @abstractmethod def getValue(self,pos:int): pass @abstractmethod def remove(self,pos:int): pass @abstractmethod def length(self) -&gt; int: pass @abstractmethod def listIterator(self) -&gt; ListIterator : #반복자 pass ArrayList(ArrayList.py)# -*- coding: utf-8 -*-from List import *from ListIterator import *import numpy as npclass ArrayList(List): DefaultSize:int=10 data=None def __init__(self,size=DefaultSize): ArrayList.data=np.zeros(size*2) #더블링 기법 self.listSize=0 #클래스 메서드(class method)란 객체가 아닌 클래스 자체에 묶여있는(bound to) 메서드이다. # 또다른 생성자 선언 @classmethod def from_size(cls,size): ArrayList.data=np.zeros(size) return cls(size) #cls로 __init__으로 넘겨준 후 리턴 def length(self): return self.listSize def clear(self): self.listSize=0 def update(self,pos:int,item:E): ArrayList.data[pos]=item def getValue(self,pos:int): return ArrayList[pos] def append(self,item:E): ArrayList.data[self.listSize]=item self.listSize+=1 def insert(self,pos:int,item:E): # 끝에부터 포스 앞까지 뒤로 당김 for i in range (self.listSize,pos,-1): ArrayList.data[i]=ArrayList.data[i-1] ArrayList.data[pos]=item self.listSize+=1 def remove(self,pos:int): ret=ArrayList.data[pos] # 왼쪽으로 옮기기 for i in range(pos,self.listSize): ArrayList.data[i]=ArrayList.data[i+1] self.listSize-=1 #사이즈 감소 return ret def listIterator(self) -&gt; ListIterator: #반복자 return self.ArrayListIterator(self) #바깥 클래스 전달 class ArrayListIterator(ListIterator): def __init__(self,outer): self.outer:ArrayList=outer self.pos:int=0 def hasNext(self) -&gt; bool: return self. pos &lt; self.outer.listSize def next(self) -&gt; E: tmp= self.outer.data[self.pos] self.pos+=1 return tmp def hasPrevious(self) -&gt; bool: return self.pos&gt;0 def previous(self) -&gt; E: self.pos-=1 return self.outer.data[pos] Link(Link.py)# -*- coding: utf-8 -*-from typing import TypeVarE = TypeVar('E')class Link: def __init__(self,item:E,next): self.item:E=item self.next:Link=next LinkedList(LinkedList.py)# -*- coding: utf-8 -*-from List import *from Link import *from ListIterator import *class LinkedList(List): def __init__(self): self.head:Link=Link(None,None) self.tail=self.head #초기화 이므로 같은 head와 tail 같게 self.size:int=0 def clear(self): self.head=None self.tail=None self.size=0 def insert(self, pos: int, item: E): curr:Link=self.head for i in range(0,pos): curr=curr.next # 1(새 노드) # 0(현재노드) -&gt; 2(햔재노드 다음) #new_node:Link=Link(item=item,next=curr.next) 1 -&gt; 2 #curr.next=new_node 0-&gt;1 # 0-&gt;1-&gt;2 #새 노드의 다음 노드를 현재노드의 다음으로 지정 new_node:Link=Link(item=item,next=curr.next) #햔재노드의 다음을 새노드로 지정 curr.next=new_node if(curr==self.tail): #만약 현재 노드가 tail이면 self.tail=curr.next #tail 수정 self.size+=1 def append(self,item:E): new_node:Link=Link(item=item,next=None) self.tail.next=new_node self.tail=new_node self.size+=1 def update(self, pos: int, item: E): curr:Link=self.head for i in range(0,pos): # 탐색 curr=curr.next curr.next.item=item # 업데이트 def getValue(self, pos: int)-&gt; E: curr:Link=self.head for i in range(0,pos): # 탐색 curr=curr.next return curr.next.item def length(self) -&gt; int: return self.size def remove(self, pos: int) -&gt; E: curr:Link=self.head for i in range(0,pos): # 탐색 curr=curr.next #curr.next가 삭제해야할 노드 ret:E=curr.next.item if(curr.next==self.tail): #만약 삭제해야할 노드가 tail이면 self.tail=curr # tail 옮김 curr.next=curr.next.next # 다다음 것으로 옮긴다. self.size-=1 return ret def toString(self) -&gt; str: ret:str=\"\" curr:Link=self.head for i in range(0,self.size): ret+= str(curr.next.item) + \",\" curr=curr.next return ret def listIterator(self) -&gt; ListIterator: return self.LinkedListIterator(self) class LinkedListIterator(ListIterator): def __init__(self,outer): self.outer:LinkedList=outer #바깥 LinkedList를 가르킴 self.curr:Link=self.outer.head # 현재 위치를 head로 def hasNext(self) -&gt; bool: return self.curr!= self.outer.tail #현재 위치가 tail이 아니면 다음 요소가 있음 def next(self) -&gt; E: #다음 원소를 리턴 self.curr=self.curr.next return self.curr.item def hasPrevious(self) -&gt; bool: #현재가 head가 아니면 이전 값이 있음 return self.curr!=self.outer.head def previous(self) -&gt; E: prev:Link =self.outer.head #head 부터 현재 이전까지 이동 while(prev.next != self.curr): prev=prev.next self.curr=prev # 현재를 이전으로 이동 #노드와 노드 사이를 가르키고 있다고 생각하면 된다. # head -&gt; 1-&gt; 2 -&gt; 3(prev) -&gt;curr-&gt; 4 # head -&gt; 1-&gt; 2 -&gt; curr -&gt; 3 -&gt;4 # curr.next=3 return self.curr.next.item 실제 구현동작 확인(test.py)from ArrayList import *from LinkedList import *if __name__==\"__main__\": mylist2=ArrayList() mylist2.append(3) mylist2.append(5) mylist2.append(6) mylist2.append(7) mylist2.append(8) mylist2.append(9) print(mylist2.data) iter2:ListIterator = mylist2.listIterator() while(iter2.hasNext()): print(int(iter2.next())) print(\"###################\") myList=LinkedList() myList.append(3) print(myList.toString()) myList.insert(0,1) print(myList.toString()) myList.insert(0,4) print(myList.toString()) myList.append(10) print(myList.toString()) myList.insert(1,5) print(myList.toString()) print(\"Remove value: \",myList.remove(1)) print(myList.toString()) print(\"Length: \",myList.length()) iter:ListIterator=myList.listIterator() while(iter.hasNext()): print(iter.next()) while(iter.hasPrevious()): print(iter.previous())결과LinkedList의 한계 previous 연산이 $O(n^2)$ 걸림 해결 방안 Double Linked List" }, { "title": "전화번호 목록", "url": "/posts/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2", "date": "2022-03-30 16:20:00 +0900", "snippet": "튜플 문제링크 문제분석 str1.find(str2) 이용 str1.find(str2) //str1안에서 str2 찾은 인덱스 리턴 없을 시 string::npos 리턴 전체코드#include &lt;bits/stdc++.h&gt;using namespace std;bool solution(vector&lt;string&gt; phone_book) { sort(phone_book.begin(),phone_book.end()); for(int i=0;i&lt;phone_book.size()-1;i++) { const string now =phone_book[i]; const string next =phone_book[i+1]; const int index=next.find(now); //만약 찾았는데 if(index==0) return false; // 그 위치가 0(처음부터) 시작이면 접두어 맞음 } return true;}" }, { "title": "튜플", "url": "/posts/%ED%8A%9C%ED%94%8C/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2", "date": "2022-03-29 23:30:00 +0900", "snippet": "튜플 문제링크 문제분석 count와 pair 클래스를 이용한 내림차순 정렬이요 전체코드#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; solution(string s) { vector&lt;int&gt; answer; int st[100001]={0,}; string tmp=\"\"; for(char i: s){ if(i-'0' &gt;=0 &amp;&amp; i-'0' &lt;=9){ //숫자만 걸려내고 tmp += i; } else{ //숫자가아닌 괄호나 쉼표 만나면 숫자 처리를 해줌 if(tmp.length()!=0) st[stoi(tmp)]++, tmp.clear(); //count 증가 } } vector&lt;pair&lt;int, int&gt;&gt; v; // &lt;카운트,해당 숫자&gt; for(int i =0; i &lt;100001; i++) if(st[i]) v.push_back({st[i], i}); sort(v.begin(), v.end(),greater()); //count 내림차순으로 정렬 //카운트 값이 클수록 앞에 나왔다는 얘기므로 for(auto it: v) answer.push_back(it.second); return answer; }" }, { "title": "배열초기화", "url": "/posts/%EB%B0%B0%EC%97%B4%EC%B4%88%EA%B8%B0%ED%99%94/", "categories": "Algorithm, Array", "tags": "Initialize, C++", "date": "2022-03-29 17:50:00 +0900", "snippet": "배열초기화 malloc(): 해당 타입의 포인터에 해당 크기만큼 메모리 할당 (쓰레기값 있음) (type *)malloc( sizeof(type)* 배열크기) calloc(): 해당 타입의 포인터에 해당 크기만큼 0으로 초기화 하여 할당(type *)calloc(배열크기,sizeof(type),) memset(): malloc으로 할당한 포인터에 초기값을 해줌 , 단 char type이나 -1~0 까지만 가능memset(포인터변수,초기값, 배열크기 * sizeof(type));//2차원memset(배열변수,초기값,sizeof(배열변수)); free(포인터 변수): 할당을 해제전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int num=10; char * arr; int * arr2; arr = (char *)malloc(sizeof(char)*num); //int [10]크기의 배열 동적할당을 합니다. sizeof(type) * 배열 크기 arr2 = (int *)calloc(num, sizeof(int)); //int [10]크기의 배열 동적할당을 합니다. (배열크기,sizeof(type) memset(arr,'Z', num * sizeof(char)); // (배열,초기화값,배열크기*sizeof(type)) //memset 0과 -1 또는 char 값을 채울 때만 사용 가눙 for (int i = 0; i &lt; num; i++) { printf(\"malloc 결과: %c\\n\", *(arr + i)); // 결과가 쓰레기 값으로 나온것을 알 수 있습니다. } printf(\"\\n\"); for (int i = 0; i &lt; num; i++) { printf(\"calloc 결과:%10d\\n\", *(arr2 + i)); // 결과가 쓰레기 값으로 나온것을 알 수 있습니다. } printf(\"\\n\"); int arr3[10][10]; cout &lt;&lt; arr3[1][1]&lt;&lt;endl; memset(arr3,0,sizeof(arr3)); cout &lt;&lt; arr3[9][9]; //2차원 배열 초기화 //우리는 동적할당으로 잡은 메모리는 해제 시켜야합니다. free(arr); free(arr2); }" }, { "title": "DSLR", "url": "/posts/DSLR/", "categories": "Algorithm, Bfs", "tags": "BOJ, C++", "date": "2022-03-29 17:37:00 +0900", "snippet": "DSLR 문제링크문제분석 (type *)calloc(size_t nelements, sizeof(type)) 을 이용하여 방문 배열 0으로 초기화 Queue를 이용한 BFS전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; #define endl \"\\n\" typedef struct _INFO{ int v; string s; }info; char dx[]={'D','S','L','R'}; int D(int a) { return a*2%10000; } int S(int a) { if(a&gt;0) return a-1; return 9999; } int L(int a) { int left= a/1000; int right = a%1000; return right*10 + left; } int R(int a) { int right= a%10; int left = a/10; return right*1000 + left; } int main() { int tc=0; cin &gt;&gt; tc; vector&lt;string&gt; ret; while(tc--) { int a,b; int *used; used=(int*)calloc(10000,sizeof(int)); cin &gt;&gt; a &gt;&gt; b; queue&lt;info&gt; q; q.push({a,\"\"}); used[a]=1; while(!q.empty()) { int now_v=q.front().v; string n_s=q.front().s; q.pop(); if(now_v==b) // 같으면 그간 과정을 담는다. { ret.push_back(n_s); break; } for(int i=0;i&lt;4;i++) //DSLR 차례대로 담아봄 { int next_v; string next_s=n_s; if(dx[i]=='D') { next_s+='D'; next_v=D(now_v); } else if(dx[i]=='S') { next_s+='S'; next_v=S(now_v); } else if(dx[i]=='L') { next_s+='L'; next_v=L(now_v); } else { next_s+='R'; next_v=R(now_v); } if(!used[next_v]) //방문하지 않았을 때만 큐에 담음 { used[next_v]=1; q.push({next_v,next_s}); continue; } } } free(used); //할당하제 } for(const string&amp; s:ret) { cout &lt;&lt; s &lt;&lt;endl; } }" }, { "title": "Linked 기반 리스트(데이터구조)[2]", "url": "/posts/List2/", "categories": "DataStructure, LinkedList", "tags": "Python", "date": "2022-03-29 14:50:00 +0900", "snippet": "리스트란?List구조의 ADT ADT: Abstract Data Type Java의 인터페이스 역할 ADT(List.py)# -*- coding: utf-8 -*-from abc import *class List(metaclass=ABCMeta): __metaclass__ = ABCMeta @abstractmethod def clear(self): pass @abstractmethod def insert(self,pos,item): pass @abstractmethod def append(self,item): pass @abstractmethod def update(self,pos,item): pass @abstractmethod def getValue(self,pos): pass @abstractmethod def remove(self,pos): pass @abstractmethod def length(self) : pass insert와 remove는 pos변수를 사용하므로 아래 그림으로 반복문 연산을 이해insertremove Link(Link.py)# -*- coding: utf-8 -*-from typing import TypeVarE = TypeVar('E')class Link: def __init__(self,item:E,next): self.item:E=item self.next:Link=next LinkedList(LinkedList.py)# -*- coding: utf-8 -*-from List import *from Link import *from ListIterator import *class LinkedList(List): def __init__(self): self.head:Link=Link(None,None) self.tail=self.head #초기화 이므로 같은 head와 tail 같게 self.size:int=0 def clear(self): self.head=None self.tail=None self.size=0 def insert(self, pos: int, item: E): curr:Link=self.head for i in range(0,pos): curr=curr.next # 1(새 노드) # 0(현재노드) -&gt; 2(햔재노드 다음) #new_node:Link=Link(item=item,next=curr.next) 1 -&gt; 2 #curr.next=new_node 0-&gt;1 # 0-&gt;1-&gt;2 #새 노드의 다음 노드를 현재노드의 다음으로 지정 new_node:Link=Link(item=item,next=curr.next) #햔재노드의 다음을 새노드로 지정 curr.next=new_node if(curr==self.tail): #만약 현재 노드가 tail이면 self.tail=curr.next #tail 수정 self.size+=1 def append(self,item:E): new_node:Link=Link(item=item,next=None) self.tail.next=new_node self.tail=new_node self.size+=1 def update(self, pos: int, item: E): curr:Link=self.head for i in range(0,pos): # 탐색 curr=curr.next curr.next.item=item # 업데이트 def getValue(self, pos: int)-&gt; E: curr:Link=self.head for i in range(0,pos): # 탐색 curr=curr.next return curr.next.item def length(self) -&gt; int: return self.size def remove(self, pos: int) -&gt; E: curr:Link=self.head for i in range(0,pos): # 탐색 curr=curr.next #curr.next가 삭제해야할 노드 ret:E=curr.next.item if(curr.next==self.tail): #만약 삭제해야할 노드가 tail이면 self.tail=curr # tail 옮김 curr.next=curr.next.next # 다다음 것으로 옮긴다. self.size-=1 return ret def toString(self) -&gt; str: ret:str=\"\" curr:Link=self.head for i in range(0,self.size): ret+= str(curr.next.item) + \",\" curr=curr.next return ret def listIterator(self) -&gt; ListIterator: return self.LinkedListIterator(self) class LinkedListIterator(ListIterator): def __init__(self,outer): self.outer:LinkedList=outer #바깥 LinkedList를 가르킴 self.curr:Link=self.outer.head # 현재 위치를 head로 def hasNext(self) -&gt; bool: return self.curr!= self.outer.tail #현재 위치가 tail이 아니면 다음 요소가 있음 def next(self) -&gt; E: #다음 원소를 리턴 self.curr=self.curr.next return self.curr.item def hasPrevious(self) -&gt; bool: #현재가 head가 아니면 이전 값이 있음 return self.curr!=self.outer.head def previous(self) -&gt; E: prev:Link =self.outer.head #head 부터 현재 이전까지 이동 while(prev.next != self.curr): prev=prev.next self.curr=prev # 현재를 이전으로 이동 #노드와 노드 사이를 가르키고 있다고 생각하면 된다. # head -&gt; 1-&gt; 2 -&gt; 3(prev) -&gt;curr-&gt; 4 # head -&gt; 1-&gt; 2 -&gt; curr -&gt; 3 -&gt;4 # curr.next=3 return self.curr.next.item 실제 구현동작 확인(test.py)from ArrayList import *from LinkedList import *if __name__==\"__main__\": myList=LinkedList() myList.append(3) print(myList.toString()) myList.insert(0,1) print(myList.toString()) myList.insert(0,4) print(myList.toString()) myList.append(10) print(myList.toString()) myList.insert(1,5) print(myList.toString()) print(\"Remove value: \",myList.remove(1)) print(myList.toString()) print(\"Length: \",myList.length())결과" }, { "title": "진법 변환(2)", "url": "/posts/%EC%A7%84%EB%B2%95-%EB%B3%80%ED%99%98(2)/", "categories": "Algorithm, Notation", "tags": "BOJ, C++", "date": "2022-03-28 00:10:00 +0900", "snippet": "진법 변환 문제링크문제분석 9가 넘었을 때 A~Z로 대체 char to string -&gt; string(1,c) 기본적인 진법 변환 나누기와 나머지 연산 사용전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; string calc(int n,const int b) { string ret=\"\"; while(n&gt;0) { int mod=n%b; string tmp=\"\"; if(mod&gt;9) tmp = string(1,char((mod-10)+'A')); else tmp= to_string(mod); ret= tmp+ret; n/=b; } return ret; } int main() { int n; int b; cin &gt;&gt; n &gt;&gt; b; cout &lt;&lt; calc(n,b); return 0; }" }, { "title": "진법 변환", "url": "/posts/%EC%A7%84%EB%B2%95-%EB%B3%80%ED%99%98/", "categories": "Algorithm, Notation", "tags": "BOJ, C++", "date": "2022-03-27 15:40:00 +0900", "snippet": "진법 변환 문제링크문제분석 진법처리 시 문자(A~Z)가 있을 시 따로 처리 reverse(s.begin(),s.end()) (뒤집기) pow(double base,double n) 사용전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int calc(string s,const int b) { int ret=0; reverse(s.begin(),s.end()); for(int i=0;i&lt;s.size();i++) { int now=0; if('A'&lt;=s[i]&amp;&amp;s[i]&lt;='Z') now=10+s[i]-'A'; else now=s[i]-'0'; const int conv=(int)pow((double)b,(double)i) * now; ret+= conv; } return ret; } int main() { string n; int b; cin &gt;&gt; n &gt;&gt; b; cout &lt;&lt; calc(n,b); return 0; }" }, { "title": "수식 최대화", "url": "/posts/%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2, Combination", "date": "2022-03-26 14:55:00 +0900", "snippet": "수식 최대화 문제링크 문제분석 next_permutation() 와 do while을 이용하여 모든 조합 순회 string to long long , stoll(str) 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; long long calc(const long long a,const long long b,char oper) { if(oper=='+') return a+b; if(oper=='-') return a-b; else return a*b; } long long solution(string expression) { vector&lt;char&gt;oper_list={'*','+','-'}; vector&lt;long long&gt; numbers; vector&lt;char&gt; opers; string tmp=\"\"; for(const char&amp; chr:expression) { if(chr=='+'||chr=='-'||chr=='*') //연산자를 기준으로 앞에 숫자 담기 { opers.push_back(chr); cout &lt;&lt; tmp &lt;&lt; \" \"; numbers.push_back(stoll(tmp)); // string -&gt; long long tmp=\"\";// 비어주고 } else tmp+=chr; } numbers.push_back(stoll(tmp)); //마지막 숫자 담기 long long ret=0; do{ vector&lt;long long&gt; temp_numbers=numbers; vector&lt;char&gt; temp_opers=opers; for(int i=0;i&lt;3;i++) //연산자 우선순위 높은 것 부터 { for(int j=0;j&lt;temp_opers.size();j++) { if(temp_opers[j]==oper_list[i]) { // j와 j+1 값을 연선하여 j에 담아두고 temp_numbers[j]=calc(temp_numbers[j],temp_numbers[j+1],temp_opers[j]); temp_numbers.erase(temp_numbers.begin()+j+1); //j+1를 제거 temp_opers.erase(temp_opers.begin()+j); //연산한 연산자는 j번째임 그러므로 제거 j--; //위에서 j+1를 연산후 필요 없어서 지웠기 때문에 다시 감소 } } } ret=max(ret,abs(temp_numbers[0])); } while(next_permutation(oper_list.begin(),oper_list.end())); //모든 조합에 대하여 우선순위 설정 return ret; }" }, { "title": "거리두기 확인하기", "url": "/posts/%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/", "categories": "Algorithm, Bfs", "tags": "Programmers, C++, Lv.2", "date": "2022-03-26 14:10:00 +0900", "snippet": "거리두기 확인하기 문제링크 문제분석 BFS와 거리두기 규칙을 통해 조건부합 확인 조건1: P:사람이 앉아있음 ,앉이있으므로 거리 2이상을 지켰는지 확인 조건2: X:앉지 못함 조건3: O:앉을 수 있음 조건4: 범위를 넘었는지 확인(다음 위치가 0미만,4초과인지) 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int x_move[]={1,0,-1,0}; //우 하 좌 상 int y_move[]={0,1,0,-1}; typedef struct _Info{ int x,y,d; //x좌표 y좌표 거리 }info; bool bfs(const vector&lt;string&gt;&amp; map,const int x,const int y) { bool visit[5][5]={false,}, flag=true; // 방문배열,조건을 만족 했나? queue&lt;info&gt; q; q.push({x,y,0}); visit[x][y]=true; while(!q.empty()) { int curr_x=q.front().x; //현재 좌표와 거리 int curr_y=q.front().y; int curr_d=q.front().d; q.pop(); for(int i=0;i&lt;4;i++) { int next_x=curr_x+x_move[i]; // 다음 x int next_y=curr_y+y_move[i]; // 다음 y int next_d=curr_d+1; //현재거리 +1 if(next_x&lt;0 ||next_x&gt;=5 || next_y&lt;0 || next_y&gt;=5) continue; //범위를 벗어나면 continue if(visit[next_x][next_y]||map[next_x][next_y]=='X') continue; //이미 방문했거나 X(가림막일 경우) if(map[next_x][next_y]=='P') //사람이 앉앗을 경우 { if(next_d&lt;=2) //맨해튼 거리가 2보다 작을 경우 { flag=false; //false break; } } visit[next_x][next_y]=true; //방문 후 q.push({next_x,next_y,next_d});// 다음꺼 큐에 삽입 } if(!flag) break; //안에 for문을 break으로 빠져 나왔으면 현재 반복문도 빠져나옴 } return flag; } vector&lt;int&gt; solution(vector&lt;vector&lt;string&gt;&gt; places) { vector&lt;int&gt; answer; for(auto&amp; p:places) { bool flag=true; for(int i=0;i&lt;5;i++) //행 { for(int j=0;j&lt;5;j++) //열 { if(p[i][j]=='P') //현재 P일 경우 bfs { if(!bfs(p,i,j)) { flag=false; break; } } } if(!flag) break; //만약 거리두기 어긴거 찾았을 때 탈출 } if(flag) answer.push_back(1); //거리두기 어긴 사람 없으면 1 else answer.push_back(0); //있으면 0삽입 } return answer; }" }, { "title": "[1차] 뉴스 클러스터링", "url": "/posts/1%EC%B0%A8-%EB%89%B4%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2", "date": "2022-03-25 22:30:00 +0900", "snippet": "[1차] 뉴스 클러스터링 문제링크 문제분석 알파벳만 사용해야 되므로 필터링 필요 대소문자 구분이 필요없으므로 하나로 통일(필자는 대문자로) 두 문자열을 2개씩 짤라야함 집합 A,B를 unordered_map 으로 구현 전체코드 #include &lt;bits/stdc++.h&gt; #define MULTI 65536 using namespace std; int state(const char c) { int ret=0; if('a'&lt;=c &amp;&amp; c&lt;='z') ret=1; // 소문자일 경우 state 값 1 if('A'&lt;=c &amp;&amp; c&lt;='Z') ret=2;// 대문자일 경우 state 값 2 return ret; } int solution(string str1, string str2) { int answer = 0; unordered_map&lt;string,int&gt; A; unordered_map&lt;string,int&gt; B; vector&lt;string&gt; total; for(int i=0;i&lt;str1.size()-1;i++) { char c1=str1[i]; char c2=str1[i+1]; int state1=state(c1); int state2=state(c2); if(state1==1) { state1=2; c1=toupper(c1); } if(state2==1) { state2=2; c2=toupper(c2); } if(state1==2&amp;&amp;state2==2) { string temp; temp+=c1; temp+=c2; //한번도 삽입이 안됬을 때만 넣음 (중복 없이) if(A[temp]==0) total.push_back(temp); A[temp]++; //카운트는 계속 } } for(int i=0;i&lt;str2.length()-1;i++) { char c1=str2[i]; char c2=str2[i+1]; int state1=state(c1); int state2=state(c2); if(state1==1){ //소문자일 경우 state를 2로 바꾸며 대문자로 바꾼다 state1=2; c1=toupper(c1); } if(state2==1) //소문자일 경우 state를 2로 바꾸며 대문자로 바꾼다 { c2=toupper(c2); state2=2; } if(state1==2 &amp;&amp; state2==2) { string temp; temp+=c1; temp+=c2; //한번도 삽입이 안됬을 때만 넣음 (중복 없이) if (A[temp] == 0 &amp;&amp; B[temp] == 0)total.push_back(temp); B[temp]++; //카운트는 계속 } } if(total.size()==0) return MULTI; int Union=0,Intersection=0; for(int i=0;i&lt;total.size();i++) { string temp=total[i]; Union+=max(A[temp],B[temp]); //합집합 Intersection+=min(A[temp],B[temp]); //교집합 } answer=MULTI * (double(Intersection)/Union); return answer; }" }, { "title": "메뉴 리뉴얼", "url": "/posts/%EA%B4%84%ED%98%B8-%EB%B3%80%ED%99%98/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2", "date": "2022-03-25 17:30:00 +0900", "snippet": "메뉴 리뉴얼 문제링크 문제분석 해당 문제는 문제에서 요구하는 단계를 그대로 구현하면 된다. 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; #define endl \"\\n\" bool check(const string &amp;a) { int r = 0; for (char ch : a) { if (ch == '(') ++r; else --r; if (r &lt; 0) return false; //올바른 조합이 아니면 연산 시 -가 될 수 있음 } return r == 0; } string solution(string p) { if (p == \"\") return \"\"; if (check(p)) return p; //올바른 입력이면 그대로 리턴 int i, t = 0; for (i = 0; i &lt; p.size(); ++i) { //u와 v를 구분하는 위치 i를 찾아냄 if (p[i] == '(') ++t; else --t; if (t == 0) break; //t가 0일 때 찾은 것 } string u = p.substr(0, i + 1); //u 0부터 i+1개 까지 i=1이라는 것은 0~1까지 를 의미하는 것이며 0부터 2개를 잘라야함 그러므로 i+1 string v = p.substr(i + 1); //i+1부터 마지막까지 cout &lt;&lt; \"u: \" &lt;&lt; u &lt;&lt; \" \"&lt;&lt; \"v:\" &lt;&lt; v &lt;&lt;endl; if (check(u)) return u + solution(v); //만약 올바른 문자열이면 u+v에 대한 재귀 for (char &amp;ch : u) ch = ch == '(' ? ')' : '('; // u에 대한 뒤집기 // \"(\" + v에 대한 재귀 +\")\" + 위에서 뒤집은 u의 앞 뒤 자르기(1~크기-2) return string(\"(\") + solution(v) + \")\" + u.substr(1, u.size() - 2); //앞 뒤를 제거 하므로 0이아닌 1부터 size-2 개 까지 갖음 //u=1234 -&gt; size-2=4-2 , u.substr(1,u.size()-2)= (23) }" }, { "title": "메뉴 리뉴얼", "url": "/posts/%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC/", "categories": "Algorithm, Dfs", "tags": "Programmers, C++, Lv.2", "date": "2022-03-25 16:40:00 +0900", "snippet": "메뉴 리뉴얼 문제링크 문제분석 DFS와 백트래킹을 통해서 해당 문자를 통해만들 수 있는 경우의 수를 탐색 해당 조건을 만족하는지 확인 후 정렬 조건 1: 최소 2가지 이상의 단품메뉴 조건 2:코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 구조 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; //A~Z가 27 int cnt[27]; // cnt[i]=n : 길이가 i인 조합 중 최대 주문 횟수는 n번 unordered_map&lt;string,int&gt; um; // um[str]=n : 조합 str의 주문 횟수는 n번 vector&lt;string&gt; menu[27][21]; // menu[i][j] : 길이가 i이고 j번 주문된 조합들의 목록 void comb(string s, int index, string made) { if(made.size()&gt;1) //두개 이상 주문됬다면 { um[made]++; //해당 메뉴 주문 횟수 증가 cnt[made.size()]=max(cnt[made.size()],um[made]); // 조합 길이 별 최대 주문 횟수 갱신 menu[made.size()][um[made]].push_back(made); //[i][j]메뉴 조합 길이가 i면서 j번 주문 한 메뉴에 made 추가 } //백트래킹 for(int i=index+1;i&lt;s.size();i++) { made.push_back(s[i]); comb(s,i,made); made.pop_back(); } } vector&lt;string&gt; solution(vector&lt;string&gt; orders, vector&lt;int&gt; course) { vector&lt;string&gt; answer; for(string&amp; s:orders) { sort(s.begin(),s.end());//문자를 오름차순 comb(s,-1,\"\"); //빈문자열로 시작하여 해당 문자열 s로 만들 수 있는 모든 경우의 조합 탐색 } // 쿼리 수행 for(int i:course) if(cnt[i]&gt;1) // 길이가 i인 조합의 최대 주문 횟수가 1 이상인 경우만 for(string s:menu[i][cnt[i]]) answer.push_back(s); sort(answer.begin(),answer.end()); //사전 순 정렬 return answer; }" }, { "title": "배열 기반 리스트(데이터구조)[1]", "url": "/posts/List/", "categories": "DataStructure, ArrayList", "tags": "Python", "date": "2022-03-24 13:35:00 +0900", "snippet": "리스트란?List구조의 ADT ADT: Abstract Data Type Java의 인터페이스 역할 ADT(List.py)# -*- coding: utf-8 -*-from abc import *class List(metaclass=ABCMeta): @abstractmethod def clear(self): pass @abstractmethod def insert(self,pos,item): pass @abstractmethod def append(self,item): pass @abstractmethod def update(self,pos,item): pass @abstractmethod def getValue(self,pos): pass @abstractmethod def remove(self,pos): pass @abstractmethod def length(self) : pass insert와 remove는 pos변수를 사용하므로 아래 그림으로 반복문 연산을 이해insertremove ArrayList(ArrayList.py)# -*- coding: utf-8 -*-from List import *import numpy as npclass ArrayList(List): DefaultSize=10 data=None def __init__(self,size=DefaultSize): ArrayList.data=np.zeros(size*2) #더블링 기법 self.listSize=0 #클래스 메서드(class method)란 객체가 아닌 클래스 자체에 묶여있는(bound to) 메서드이다. # 또다른 생성자 선언 @classmethod def from_size(cls,size): ArrayList.data=np.zeros(size) return cls(size) #cls로 __init__으로 넘겨준 후 리턴 def length(self): return self.listSize def clear(self): self.listSize=0 def update(self,pos,item): ArrayList.data[pos]=item def getValue(self,pos): return ArrayList[pos] def append(self,item): ArrayList.data[self.listSize]=item self.listSize+=1 def insert(self,pos,item): # 끝에부터 포스 앞까지 뒤로 당김 for i in range (self.listSize,pos,-1): ArrayList.data[i]=ArrayList.data[i-1] ArrayList.data[pos]=item self.listSize+=1 def remove(self,pos): ret=ArrayList.data[pos] # 왼쪽으로 옮기기 for i in range(pos,self.listSize): ArrayList.data[i]=ArrayList.data[i+1] self.listSize-=1 #사이즈 감소 return ret 실제 구현동작 확인(test.py)from ArrayList import *if __name__==\"__main__\": mylist=ArrayList() mylist.append(3) print(mylist.data) mylist.append(5) print(mylist.data) mylist.insert(0,10) print(mylist.data) mylist.remove(2) print(mylist.data) print(mylist.length()) mylist2=ArrayList(30) print(mylist2.data) 결과 배열기반 리스트의 한계" }, { "title": "행렬 테두리 회전하기", "url": "/posts/%ED%96%89%EB%A0%AC_%ED%85%8C%EB%91%90%EB%A6%AC_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/", "categories": "Algorithm, Array", "tags": "Programmers, C++, Lv.2", "date": "2022-03-23 22:56:00 +0900", "snippet": "행렬 테두리 회전하기 문제링크 문제분석 회전하기 전 상태를 기억할 전역 행렬이 필요 함 전 상태를 기억해야만 값을 옮기기 편함 시계 방향 마다 움직임을 for문 4개로 구현 구조 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; typedef vector&lt;vector&lt;int&gt;&gt; vvi; vvi global_matrix; //이전 상태를 저장할 전역 행렬 void print(vvi&amp; tmp) { const int r=tmp.size(); const int c=tmp[0].size(); cout &lt;&lt; r &lt;&lt; \" \" &lt;&lt; c &lt;&lt; endl; for(int i=1;i&lt;r;i++) { for(int j=1;j&lt;c;j++) { cout &lt;&lt; tmp[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } } vvi init(const int r,const int c) { vvi ret(r+1,vector&lt;int&gt;(c+1,0)); for(int i=1;i&lt;=r;i++) { for(int j=1;j&lt;=c;j++) { int &amp; tmp=ret[i][j]; tmp=(i-1)*c+j; } } return ret; } int rotation(const int r1,const int r2,const int c1,const int c2,vvi&amp; matrix) { vector&lt;int&gt; switched; //-&gt; (오른쪽으로 이동 ) for(int i=c1+1;i&lt;=c2;i++) { matrix[r1][i]=global_matrix[r1][i-1]; // 전역행렬 왼쪽 값으로 현재 행렬 오른쪽으로 채움 switched.push_back(global_matrix[r1][i-1]); //움직인 값 } /* | V (아래로) */ for(int i=r1+1;i&lt;=r2;i++) { matrix[i][c2]=global_matrix[i-1][c2]; //마찬가지로 전영행렬 윗 값으로 현재행렬 아래 값을 채움 switched.push_back(global_matrix[i-1][c2]); } //&lt;- 오른쪽을 이동 for(int i=c2-1;i&gt;=c1;i--) { matrix[r2][i]=global_matrix[r2][i+1]; //전역 오른쪽을 현재 왼쪽에 넣음 switched.push_back(global_matrix[r2][i+1]); } /* ^ | 위로 */ for(int i=r2-1;i&gt;=r1;i--) { matrix[i][c1]=global_matrix[i+1][c1]; switched.push_back(global_matrix[i+1][c1]); } return *(min_element(switched.begin(),switched.end())); } vector&lt;int&gt; solution(int rows, int columns, vector&lt;vector&lt;int&gt;&gt; queries) { vector&lt;int&gt; answer; vvi matrix=init(rows,columns); //print(matrix); global_matrix=matrix; for(vector&lt;int&gt;&amp; query:queries) { const int r1=query[0]; const int c1=query[1]; const int r2=query[2]; const int c2=query[3]; answer.push_back(rotation(r1,r2,c1,c2,matrix)); global_matrix=matrix; //전역 행렬을 한번회전 후 행렬로 다시 덮어준다. } return answer; }" }, { "title": "짝지어 제거하기", "url": "/posts/%EC%A7%9D%EC%A7%80%EC%96%B4_%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/", "categories": "Algorithm, Stack", "tags": "Programmers, C++, Lv.2", "date": "2022-03-22 21:40:00 +0900", "snippet": "더 맵게 문제링크 문제분석 선입후출, 스택을 이용하여 차례대로 매칭하기 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int solution(string s) { int answer = -1; stack&lt;char&gt; st=stack&lt;char&gt;(); for(const char&amp; c:s) { if(!st.empty()&amp;&amp;st.top()!=c) { st.push(c); continue; } else if(!st.empty()&amp;&amp;st.top()==c) { st.pop(); continue; } else st.push(c); } if(st.empty()) answer=1; else answer=0; return answer; }" }, { "title": "타겟 넘버", "url": "/posts/%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84/", "categories": "Algorithm, DFS", "tags": "Programmers, C++, Lv.2", "date": "2022-03-22 21:00:00 +0900", "snippet": "타겟넘버 문제링크 문제분석 DFS와 완전탐색을 이용하여 모든 경우를 확인 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int answer = 0; vector&lt;int&gt; nums; void dfs(const int idx,const int target,const int sum) { //cout &lt;&lt; target &lt;&lt; \" \" &lt;&lt; nums[idx] &lt;&lt; \" \" &lt;&lt; sum &lt;&lt;endl; if(idx==nums.size()) { if(sum==target) answer++; return; } for(int i=0;i&lt;2;i++) { if(i==0) dfs(idx+1,target,sum-nums[idx]); else dfs(idx+1,target,sum+nums[idx]); } } int solution(vector&lt;int&gt; numbers, int target) { nums=numbers; dfs(0,target,0); return answer; }" }, { "title": "더 맵게", "url": "/posts/%EB%8D%94-%EB%A7%B5%EA%B2%8C/", "categories": "Algorithm, Heap", "tags": "Programmers, C++, Lv.2", "date": "2022-03-22 20:40:00 +0900", "snippet": "더 맵게 문제링크 문제분석 Heap, 우선순위 큐를 사용하여 오름차순으로 정렬 후 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) $k3= k1 + k2 \\times 2$ 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int solution(vector&lt;int&gt; scoville, int K) { int answer = 0; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; for(const int k:scoville) { pq.push(k); } while(pq.size()&gt;1) { int k1=pq.top(); pq.pop(); if(k1&gt;=K) break; int k2=k2=pq.top(); pq.pop(); pq.push(k1+k2*2); answer++; } if(pq.top()&lt;K) return -1; return answer; }" }, { "title": "기능개발", "url": "/posts/%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/", "categories": "Algorithm, Queue", "tags": "Programmers, C++, Lv.2", "date": "2022-03-22 20:40:00 +0900", "snippet": "기능개발 문제링크 문제분석 선입선출, Queue를 이용한 기본적인 문제 해당 업무와 스피드를 매칭시키기위해 Pair객체 사용 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; typedef vector&lt;pair&lt;int,int&gt;&gt;::iterator vi; void runTask(vector&lt;pair&lt;int,int&gt;&gt;&amp;comb) { for(int i=0;i&lt;comb.size();i++) //해당 스피드만 큼 프로세스 진행 { comb[i].first+=comb[i].second; } } void init(vector&lt;pair&lt;int,int&gt;&gt;&amp;comb,vector&lt;int&gt; &amp;p, vector&lt;int&gt;&amp; s) { for(int i=0;i&lt;p.size();i++) { comb.push_back({p[i],s[i]}); } } vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds) { vector&lt;int&gt; answer; vector&lt;pair&lt;int,int&gt;&gt; comb; init(comb,progresses,speeds); while(comb.size()!=0) { int cnt=0; //해당 일 수에 끝낸 작업 개수 if((*(comb.begin())).first&lt;100) //가장 앞에있는 작업이 안끝났으면 작업 1회전 진행 { runTask(comb); continue; } while((*(comb.begin())).first&gt;=100&amp;&amp;!comb.empty()) //가장 앞 작업이 끝났다면 { cnt++; // 작업 개수 증가 comb.erase(comb.begin()); //작업 제거 } if(cnt!=0) answer.push_back(cnt); //해결된 작업이 있으면 담는다. } return answer; }" }, { "title": "멀쩡한 사각형", "url": "/posts/%EB%A9%80%EC%A9%A1%ED%95%9C%EC%82%AC%EA%B0%81%ED%98%95/", "categories": "Algorithm, Gcd", "tags": "Programmers, C++, Lv.2", "date": "2022-03-22 17:10:00 +0900", "snippet": "멀쩡한 사각형 문제링크 문제분석 대각선으로 지나는 사각형의 규칙이 최대공약수(GCD)와 관련이 있다. 대각선이 지나닌 일정한 패턴 개수(n) $n=gcd(w,h)$패턴 당 제거되는 사각형의 개수(k) $k=\\frac{w}{gcd(w,h)} + \\frac{h}{gcd(w,h)} -1$ 총 제거 개수: $n \\times k$ 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; long long solution(int w,int h) { long long answer = 1; long long tmp = (long long) w * (long long) h; const int _gcd=gcd(w,h); answer= tmp - (w+h-_gcd); return answer; }" }, { "title": "124나라의 숫자", "url": "/posts/124%EB%82%98%EB%9D%BC_%EC%88%AB%EC%9E%90/", "categories": "Algorithm, Notation", "tags": "Programmers, C++, Lv.2", "date": "2022-03-22 17:10:00 +0900", "snippet": "124나라의 숫자 문제링크 문제분석 2진법 계산의 확장편으로 생각하면 편하다. 여기서 중요한 것은 연속된 숫자가 아닌 1,2,4이다. 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; string arr[] ={\"4\",\"1\",\"2\"}; string solution(int n) { string answer = \"\"; while(n&gt;0) { string tmp=answer; answer =arr[n%3]+tmp; // 현재계산값 + 이전계산값(이전 것을 뒤에 붙혀주는게 포인트) if(n%3==0) n=(n/3)-1; //연속되지 않은 1,2,4이기 때문에 else n/=3; } return answer; }" }, { "title": "단체사진 찍기", "url": "/posts/%EB%8B%A8%EC%B2%B4%EC%82%AC%EC%A7%84_%EC%B0%8D%EA%B8%B0/", "categories": "Algorithm, DFS", "tags": "Programmers, C++, Lv.2", "date": "2022-03-21 22:45:00 +0900", "snippet": "단체사진 찍기 문제링크 문제분석 DFS와 백트래킹을 이용하여 모든 경우의 수를 계산하고 담겨있는 인원들의 인덱스를 이용하여 거리계산 후 조건을 만족하는지 판단 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; int answer; bool selected[8]; char people[8]={'A','C','F','J','M','N','R','T'}; // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요. void DFS(const int cnt,char arr[],vector&lt;string&gt;&amp; data) //현재 인원 수,자리 공간 배열,요구 조건 { if(cnt==8) //모두 담았을 때 { for(int i=0;i&lt;data.size();i++) { //정보 형식: N~F=0 , N:조건 요구 사람(0), ~(1),타겟 사람(2),조건식=(3),거리(4) // 인덱스 0 2 3 4 만 사용 char ask=data[i][0]; char target=data[i][2]; char oper=data[i][3]; int dist=data[i][4]-'0'; //char to int dist++; // 거리=인덱스1-인덱스2 -1 이므로 // 123 일때 1과2의 거리는 0 , 1과 3의 거리는 1이다. // 3-1= 2 -1 =거리=1 성립 //그렇다면 거리+1=인덱스1-인덱스2 이므로 ++ 시켜준다 int idx,iidx; //-1로 초기화 idx=iidx=-1; for(int j=0;j&lt;8;j++) { if(ask==arr[j]) idx=j; //현재 조건 요청자의 위치를 찾는다. if(target==arr[j]) iidx=j; //현재 타겟의 위치를 찾는다 if(idx!=-1&amp;&amp;iidx!=-1) break; //모두 찾앗다면 break; } if(oper=='='&amp;&amp;abs(idx-iidx)!=dist) return; //해당 oper가 = 이고 해당 위치 차이(거리)가 같지 않을 때 조건을 성립하지 못햇을 때 if(oper=='&lt;'&amp;&amp;abs(idx-iidx)&gt;=dist) return; // &lt;인데 같거나 크면 조건 성립 x if(oper=='&gt;'&amp;&amp;abs(idx-iidx)&lt;=dist) return; // &gt;인데 작거나 같으면 조건 성립 x } answer++; //모든 검증 끝나면 경우의 수 1 증가 return; } for(int i=0;i&lt;8;i++) { if(selected[i]==true) continue; selected[i]=true; arr[cnt]=people[i]; DFS(cnt+1,arr,data); selected[i]=false; } } int solution(int n, vector&lt;string&gt; data) { answer=0; char arr[8] = {NULL,}; DFS(0,arr,data); return answer; }" }, { "title": "카카오프렌즈 컬러링북", "url": "/posts/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%94%84%EB%A0%8C%EC%A6%88_%EC%BB%AC%EB%9F%AC%EB%A7%81%EB%B6%81-copy/", "categories": "Algorithm, BFS", "tags": "Programmers, C++, Lv.2, Queue", "date": "2022-03-21 21:30:00 +0900", "snippet": "카카오프렌즈 컬러링북 문제링크 문제 분석 같은 영역은 같은 색 코드와 끊김이 없어여야함 BFS를 이용하므로 범위를 벗어 났는지 방문은 했었는지 체크를 해야한다. 구현 컨셉 상하좌우 이동 구현 int dx[]={0,0,-1,1}; // 좌 우 int dy[]={-1,1,0,0}; // 상 하 방문기록 2차원 배열 #define MAX 10 bool isVisit[MAX][MAX]; fill(&amp;isVisit[0][0], &amp;isVisit[MAX][MAX+1], false); 전체코드 #include &lt;bits/stdc++.h&gt; using namespace std; // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요. int f_max(const int a,const int b) { return a&gt;b ? a : b; } int dx[]={0,0,-1,1}; // 좌 우 int dy[]={-1,1,0,0}; // 상 하 int g_m=0,g_n=0; #define MAX 100 bool isVisit[MAX][MAX]; int bfs(const int i,const int j,vector&lt;vector&lt;int&gt;&gt; &amp;map) { int color=map[i][j]; //현재 색 int size=1; queue&lt;pair&lt;int,int&gt;&gt; q; q.push({i,j});// 큐삽입 (BFS) isVisit[i][j]=true; //출발점은 방문 처리 while(!q.empty()) { int curr_x=q.front().first; //현재 x int curr_y=q.front().second; //현재 y q.pop(); for(int move=0;move&lt;4;move++) //4가지 무브 먼트 { int next_x=curr_x+dx[move]; //다음 x int next_y=curr_y+dy[move]; //다음 y if((next_x&gt;=0&amp;&amp; next_x&lt;g_m) &amp;&amp; (next_y&gt;=0 &amp;&amp; next_y&lt;g_n)) //범위를 안나가고 { if(color==map[next_x][next_y] &amp;&amp; isVisit[next_x][next_y]==false) { //현재 색깔과 다음 색깔이 같고 아직 다음 좌표 방문하지 않앗다면 isVisit[next_x][next_y]=true; //방문 처리 size++; //사이즈 증가 q.push({next_x,next_y}); // 큐삽입 } } } } return size; } vector&lt;int&gt; solution(int m, int n, vector&lt;vector&lt;int&gt;&gt; picture) { g_m=m,g_n=n; fill(&amp;isVisit[0][0], &amp;isVisit[MAX][MAX+1], false);// 0,0 99,99 까지 false로 초기화 100 x 100 초기화, colum쪽은 +1 해줘야함 vector&lt;int&gt; answer(2,0); int number_of_area = 0; int max_size_of_one_area = 0; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { int color=picture[i][j]; if(color!=0&amp;&amp;isVisit[i][j]==false)//현재 색이 0이아니고 아직 방문 하지 않았다면 { int _size=bfs(i,j,picture); //해당 색 영역 크기 탐색 max_size_of_one_area=f_max(max_size_of_one_area,_size); //최대값 number_of_area++;//영역 하나 증가 } } } answer[0] = number_of_area; answer[1] = max_size_of_one_area; return answer; }" }, { "title": "오픈채팅방", "url": "/posts/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2", "date": "2022-03-21 19:30:00 +0900", "snippet": "오픈채팅방 문제링크 제한사항 id를 저장할 벡터, 상태를 저장할 벡터, id를 key로 닉네임을 가져올 맵 사용하여 id에 따른 상태 또는 닉네임 변경을 관리한다. 구조 전체코드 #include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"vector&lt;string&gt; solution(vector&lt;string&gt; record) { vector&lt;string&gt; answer; vector&lt;string&gt; state; unordered_map&lt;string,string&gt; userInfo; for(int i=0;i&lt;record.size();i++) { string command[3]; int index=0; stringstream ss(record[i]); // 벡터안에 문자열 한줄이 모두 stringstream에 들어감 string temp; while(ss&gt;&gt;temp) //공백과 줄바꿈을 제외한 문자들 추출 { command[index++]=temp; } if(command[0]==\"Enter\") { userInfo[command[1]]=command[2]; //command[1]=id, command[2]=닉네임 answer.push_back(command[1]); //id만 갖고있는다 state.push_back(\"들어왔습니다.\");//Enter State 삽입 } else if(command[0]==\"Change\") { userInfo[command[1]]=command[2]; //변경 } else { answer.push_back(command[1]); //id만 갖고 있는다. state.push_back(\"나갔습니다.\"); //Leave State 삽입 } } for(int i=0;i&lt;answer.size();i++) { answer[i]=userInfo[answer[i]]+\"님이 \"+state[i]; //answer에 저장된 id를 닉네임으로 바꾼후 +\"님이 \" +해당 상태 } return answer;}" }, { "title": "직사각형 별찍기", "url": "/posts/%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84%EC%B0%8D%EA%B8%B0/", "categories": "Algorithm", "tags": "C++, Programmers, Lv.1", "date": "2022-03-20 20:00:00 +0900", "snippet": "직사각형 별찍기문제해석 해당 문제는 가로 길이 n괴 세로길이 m 을 입력 받아 ‘*’ 모양을 이용하여 직사각형을 만드는 문제#include &lt;iostream&gt;using namespace std;int main(void) { int a; int b; cin &gt;&gt; a &gt;&gt; b; int i=0; // 세로 while(i&lt;b) { int j=0; //가로 while(j&lt;a){ cout&lt;&lt;\"*\"; j++; } cout &lt;&lt;endl; i++; } return 0;}" }, { "title": "신규 아이디 추천", "url": "/posts/%EC%8B%A0%EA%B7%9C_%EC%95%84%EC%9D%B4%EB%94%94_%EC%B6%94%EC%B2%9C/", "categories": "Algorithm, String", "tags": "C++, Programmers, Bit operation, Lv.1", "date": "2022-03-20 20:00:00 +0900", "snippet": "신규 아이디 추천제약 조건 아이디의 길이는 3자 이상 15자 이하여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다. 단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다. 1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다. 2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(), 마침표(.)_를 제외한 모든 문자를 제거합니다. 3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다. 4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다. 5단계 new_id가 빈 문자열이라면, new_id에 “a”를 대입합니다. 6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다. 7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.문제 해석 대 -&gt; 소문자: (비트연산 XOR 이용) 대소문자는 6번째 비트가 다름 필터링(소문자,숫자,-,_,.) : if 조건문 과 strchr 함수 사용 char * strchar(char* str,int c):해당 문자 c가 str안에 들어가면 해당 위치 없으면 Null 리턴 또다른 string 변수를 이용하여 ‘.’이 중복되어있는지 확인 front(),back(), erase(),pop_back() 함수 이용 empty()함수 이용 size()함수로 16글자 초과를 체크하고 substr(strat,count)를 이용하여 자름 size()함수로 글자가 2이하인지 체크 후 글자가 초과할 때 까지 back()(마지막 문자)를 넣음#include &lt;bits/stdc++.h&gt;using namespace std;string solution(string new_id) { for (char&amp; ch : new_id){ if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z'){ ch ^= 0b100000; /** 대문자의 아스키코드는 모두 여섯번째비트가 0이고 소문자의 경우에는 여섯번째 비트가 모두1이다. 즉 6번 째 자리 비트만 변경하면됨 그러므로 변환은 32(0x20) 즉 ob100000 와 or 또는 xor연산 하면 됨 a ^= ob100000 ,|=ob100000, ^=32,|=32,^=ox20, |=0x20= 모두 같은 연산 */ } } string ret; for (char&amp; ch: new_id) { if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z' || '0' &lt;= ch &amp;&amp; ch &lt;= '9' || strchr(\"-_.\", ch)) ret += ch; /* char* strchr (char* str, int c); 해당 문자열(str)에 해당 문자 c가 존재하면 해당 존재하는 곳 포인터 없으면 Null 그러므로 ,a~z,0~9,-_. 어느 곳 안에 포함되면 ret에 뒤에서 앞으로 삽입 됨 */ } new_id = ret; ret.clear(); for (char&amp; ch: new_id) { if (!ret.empty() &amp;&amp; ret.back() == '.' &amp;&amp; ch == '.') continue; //비어 있지 않고 현재 마지막(ret.back)이 .이고 현재 삽입 고민중인 문자(ch)가 . 이면 넘어감 ret += ch; } if (ret.front() == '.') ret.erase(ret.begin()); if (ret.back() == '.') ret.pop_back(); //처음과 마지막이 .이면 삭제 if (ret.empty()) ret = \"a\"; //버이있으면 a if (ret.size() &gt;= 16) ret = ret.substr(0, 15); //16 이상 일시 0~15까지만 남음 if (ret.back() == '.') ret.pop_back(); //여전히 마지막에 .존재시 삭제 while (ret.size() &lt;= 2) ret += ret.back(); //3이 될 때까지 ret.back()을 계속 더함 return ret;}" }, { "title": "문자열 압축", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%95%95%EC%B6%95/", "categories": "Algorithm, String", "tags": "Programmers, C++, Lv.2", "date": "2022-03-20 14:00:00 +0900", "snippet": "문자열 압축 문제링크문제 해석 최대로 자를수 있는 길이는 주어진 문자열의 딱 절반 까지이다. 또한 초기 answer은 1개씩 잘랐던 것을 기준으로 주어진 문자열 길이가 된다. 기본 구현#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"int f_min(const int a,const int b){ return a&lt;b ? a : b;}int solution(string s) { int len=s.length(); int answer = len; //초기값 int n=len/2; //자를 수 있는 최대 길이 } 길이를 기준으로 검사for(int i=1;i&lt;=n;i++) //문자열을 자를 길이 (1~절반) { string conv,pattern; pattern=s.substr(0,i); //처음부터 i개 까지 패턴 설정 int cnt=1; // 해당 패턴과 같은 개수 for(int j=i;j&lt;=len;j+=i) //패턴 길이만큼 건너뛰며 확인 { if(pattern==s.substr(j,i)) //j부터 i개를 짜른게 패턴과 같다면 { cnt++; } else //같지 않으면 이제 처리를 해줘야함 { if(cnt==1) //만약 1이라면 자신을 제외한 패턴이 없는 것 { conv+=pattern; //abc } else { conv+=(to_string(cnt) + pattern); //2abc } pattern=s.substr(j,i); //패턴 변경 cnt=1; // 카운트 초기화 } if((len%i)!=0) //i(해당 패턴 길이) 패턴 길이로 전체 문자열 길이가 나누어 떨어지지 않으면 잔여 문자 존재 { //(len/i) *i -&gt; 아직 확인하지 않은 끝부분 시작 점 //len/i = 문자열/해당 패턴 길이 cout &lt;&lt; \"len(pattern): \" &lt;&lt; i &lt;&lt;endl; cout &lt;&lt; s.substr((len / i)*i) &lt;&lt; \" \" &lt;&lt; len &lt;&lt;endl; conv+=s.substr((len / i)*i,len); //검사 끝난 부분부터 끝까지 } if(answer&gt;conv.length()) answer=conv.length();// 길이 최솟 값 }전체코드#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"int f_min(const int a,const int b){ return a&lt;b ? a : b;}int solution(string s) { int len=s.length(); int answer = len; int n=len/2; for(int i=1;i&lt;=n;i++) //문자열을 자를 길이 { string conv,pattern; pattern=s.substr(0,i); //처음부터 i개 까지 패턴 설정 int cnt=1; for(int j=i;j&lt;=len;j+=i) //패턴 길이만큼 건너뛰며 확인 { if(pattern==s.substr(j,i)) //j부터 i개를 짜른게 패턴과 같다면 { cnt++; } else //같지 않으면 이제 처리를 해줘야함 { if(cnt==1) //만약 1이라면 자신을 제외한 패턴이 없는 것 { conv+=pattern; //abc } else { conv+=(to_string(cnt) + pattern); //2abc } pattern=s.substr(j,i); //패턴 변경 cnt=1; // 카운트 초기화 } } if((len%i)!=0) //i(해당 패턴 길이) 패턴 길이로 전체 문자열 길이가 나누어 떨어지지 않으면 잔여 문자 존재 { //(len/i) *i -&gt; 아직 확인하지 않은 끝부분 시작 점 //len/i = 문자열/해당 패턴 길이 cout &lt;&lt; \"len(pattern): \" &lt;&lt; i &lt;&lt;endl; cout &lt;&lt; s.substr((len / i)*i) &lt;&lt; \" \" &lt;&lt; len &lt;&lt;endl; conv+=s.substr((len / i)*i,len); //검사 끝난 부분부터 끝까지 } if(answer&gt;conv.length()) answer=conv.length();// 길이 최솟 값 } return answer;}" }, { "title": "template_kr", "url": "/posts/template_kr/", "categories": "MarkDown", "tags": "readme", "date": "2022-03-17 09:00:00 +0900", "snippet": "포스트 템플릿파일명:YYYY-MM-DD-postName.md 속성 명 기능 예 title 제목을 설정 title: “템플릿” author 작성자 설정 author: “name” date 작성 날짜 date: 2022-03-17 last_modified_at 최근 수정날짜 last_modified_at: 2020-05-05 categories 카테고리를 설정 배열 형태 categories: [a(대 분류),b(소 분류)] tags 테그 설정 배열 형태 (무조건 소문자) tags:[a] pin 핀 설정 (true) pin: true changefreq 해당 게시글의 변동 주기 always,hourly,daily,weekly,monthly,yearly,never priority 우선순위(0.0~1.0) priority:1.0 " }, { "title": "template_en", "url": "/posts/template_en/", "categories": "MarkDown", "tags": "readme", "date": "2022-03-17 09:00:00 +0900", "snippet": "This post will guide you how to write a post on Chirpy theme. Even if you have previous experience with Jekyll, this article is worth reading, because many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG names should always be lowercase--- The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:Add author information in _data/authors.yml (If your website doesn’t have this file, don’t hesitate to create one.)&lt;author_id&gt;: name: &lt;full name&gt; twitter: &lt;twitter_of_author&gt; url: &lt;homepage_of_author&gt;And then set up the custom author in the post’s YAML block:---author: &lt;author_id&gt;--- Another benefit of reading the author information from the file _data/authors.yml is that the page will have the meta tag twitter:creator, which enriches the Twitter Cards and is good for SEO.Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesCaptionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image:![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right. Once the position is specified, the image caption should not be added. Normal position Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } Float to the left ![Desktop View](/assets/img/sample/mockup.png){: .left } Float to the right ![Desktop View](/assets/img/sample/mockup.png){: .right } ShadowThe screenshots of the program window can be considered to show the shadow effect, and the shadow will be visible in the light mode:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.comOnce img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&lt;img src=\"https://cdn.com/path/to/flower.png\" alt=\"The flower\"&gt;Image PathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&lt;img src=\"/img/path/flower.png\" alt=\"The flower\"&gt;Preview ImageIf you want to add an image to the top of the post contents, specify the attribute path, width, height, and alt for the image:---image: path: /path/to/image/file width: 1000 # in pixels height: 400 # in pixels alt: image alternative text---Except for alt, all other options are necessary, especially the width and height, which are related to user experience and web page loading performance. The above section “Size” also mentions this.Starting from Chirpy v5.0.0, the attributes height and width can be abbreviated: height → h, width → w. In addition, the img_path can also be passed to the preview image, that is, when it has been set, the attribute path only needs the image file name.Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---PromptsThere are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows:&gt; Example line for prompt.{: .prompt-info }SyntaxInline Code`inline code part`Filepath Hightlight`/path/to/a/file.extend`{: .filepath}Code BlockMarkdown symbols ``` can easily create a code block as follows:```This is a plaintext code snippet.```Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value``` The Jekyll tag {% highlight %} is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it:```shellecho 'No more line numbers!'```{: .nolineno }Specifying the FilenameYou may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=\"path/to/file\" }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains 'Pack' %} This product's title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts." } ]
